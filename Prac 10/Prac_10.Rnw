\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
%\usepackage{bbold}
\usepackage{tikz}
%\usepackage{silence}
\usepackage{mdframed}
%\WarningFilter{mdframed}{You got a bad break}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}
\usepackage{color}
\colorlet{exampcol}{blue!10}
\usepackage{multicol}
\usepackage{booktabs}

\title{BIO311: Population Ecology\\ \textit{Practical 10:\\ Stochasticity in Matrix Models\\ Population Viability Analysis\\ \& Metapopulation Dynamics.}}
\setlength\parindent{0pt}

\setcounter{tocdepth}{1} % Determines the depth of the table of contents;; 0:chapters, 1: chapters and sections, 2: chapters,sections and subsections

%\renewcommand{\theExercise}{\thechapter.\arabic{Exercise}}%

\setlength\parindent{0pt}
\begin{document}
\input{../authors}

\maketitle
\tableofcontents
\vspace{3cm}

\newpage
<<setup, cache=FALSE, include=FALSE>>=
opts_chunk$set(dev="tikz",tidy=F,dev.args=list(pointsize=7.5))
options(width=60)
@
<<beta,echo=FALSE,eval=T,results='hide',message=FALSE>>=
library('xtable')
library('popbio')
  
A<-matrix(c(0,0.25,2,0.5), nr=2)

B<-matrix(c(0,0.27,2,0.54), nr=2)

C<-matrix(c(0,0.2,1.8,0.44), nr=2)

@
\section{Environmental Stochasticity}
In practical $9$ we investigated the population dynamics for two populations of yellow-necked mice. Here we focus on one of the two populations presented in that practical: the population living on the plain. For this population the Leslie matrix was given by:
<<alpha1,results='asis',echo=FALSE,message=FALSE>>=
cat("\\begin{equation*} \\boldsymbol{A}=")
 print(xtable(A,align=rep("",ncol(A)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("\\end{equation*}")
@
It turns out however that the conditions for the population are not the same every year. Measurements have been done (okay, this is what we say, in reality we made up some numbers that give reasonable results in the end...) for three years in a row and the matrices that were found for these years are shown below:
<<alpha,results='asis',echo=FALSE,message=FALSE>>=
  
cat("\\begin{align*}")
cat("\\boldsymbol{A_1} &=")
 print(xtable(A,align=rep("",ncol(A)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("& \\boldsymbol{A_2} &=")
 print(xtable(B,align=rep("",ncol(A)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("& \\boldsymbol{A_3} &=")
 print(xtable(C,align=rep("",ncol(A)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)

cat("\\\\ \\lambda &=",lambda(A),"&\\lambda &=",lambda(B),"&\\lambda &=",lambda(C))
cat("\\end{align*}")

@
We see that the year that we considered was a relatively average year. The year after the survival rates of the individuals was higher at both stages. In the third year however the population experienced some severe conditions with the survival rates and the fertility rate being lower than in both preceding years.

We thus have to realise that the transition rates in nature will vary from year to year. This would mean that the Leslie matrix would also look differently every year. Two possibilities of taking this into account when predicting the behaviour of the population are given below:
\begin{enumerate}
\item From the matrices we see that the mean fertility rate is $\mu_{F} = \Sexpr{mean(c(A[1,2],B[1,2],C[1,2]))}$ with a standard deviation of $\sigma_{F} = \Sexpr{sd(c(A[1,2],B[1,2],C[1,2]))}$. For the survival rates we find:
\begin{align*}
\mu_{S_j} &= \Sexpr{mean(c(A[2,1],B[2,1],C[2,1]))} & \sigma_{S_j} &= \Sexpr{sd(c(A[2,1],B[2,1],C[2,1]))}\\
\mu_{S_a} &= \Sexpr{mean(c(A[2,2],B[2,2],C[2,2]))} & \sigma_{S_a} &= \Sexpr{sd(c(A[2,2],B[2,2],C[2,2]))}
\end{align*}
For every time step that we project the population in the future, we generate a matrix $\boldsymbol{A}$ with a random fertility rate (drawn from a normal distribution with mean $\mu_F$ and standard deviation $\sigma_F$), a random juvenile survival rate (drawn from a normal distribution with mean $\mu_{S_j}$ and standard deviation $\sigma_{S_j}$) and a random adult survival rate (drawn from a normal distribution with mean $\mu_{S_a}$ and standard deviation $\sigma_{S_a}$). This way we will incorporate the fact that the rates can vary over time.
\begin{mdframed}
\textbf{Quick refresher: standard deviation}\\
The standard deviation describes how much variation there is in the data from the average. A large standard deviation means that the data points deviate a lot from the average whereas a small standard deviation indicates that the data points are close to the average. Mathematically it is defined as:
\begin{equation*}
\sigma = \sqrt{\frac{1}{N-1}\sum_{i=1}^{N}{(x_i-\mu)^2}}.
\end{equation*}
In this equation $\mu$ is the average value of $x$ (thus $\mu=\frac{1}{N}\sum_{i=1}^{N}{x_i}$) and $N$ is the total number of data points. In \texttt{R} you can use the function \texttt{sd()} to calculate the standard deviation.
\end{mdframed}
\item Every time step we randomly choose one of the measured matrices ($\boldsymbol{A_1,A_2,A_3}$) with equal probabilities. Thereby taking into account the variation in the environment.
\end{enumerate}
Which of these approaches do you prefer in this case? And why?
\begin{mdframed}
\textbf{If-statements}\\ The last \texttt{R} element that we will use in the practicals is the \texttt{if} statement. This allows us to make choices in the program depending on the value of a variable. For this, there is series of test that can be performed, we show the most important ones here:\\
\begin{tabular}{l l}
\texttt{a==b} & a is equal to b\\
\texttt{a>b} & a is larger than b\\
\texttt{a<b} & a is smaller than b\\
\texttt{a!=b} & a is not the same as b\\
\end{tabular}\\
Furthermore there are ways to combine tests:\\
\begin{tabular}{l l}
\texttt{test1 \& test2} & test1 and test2 are both true.\\
\texttt{test1 | test2} & at least test1 or test2 is true\\
\end{tabular}\\
We can now use these tests with an \texttt{if} statement to make the code more flexible. An \texttt{if} statement looks as follows:
<<captainiglo,eval=FALSE>>=
if(test){
  ... what to do in case the test is true
}
@
To test youreself, what would the value of \texttt{b} be after you run this code?
<<dr_oetker,eval=FALSE>>=
a <- 7
b <- 3
if(a > 5){
  b <- 6
}
@
And after this code?
<<magnum,eval=FALSE>>=
a <- 7
b <- 3
if(a == 5){
  b <- 6
}
@
Finally, we can extend \texttt{if} statements. So far we only say, what the code should do if a certain test is true, but what if it isn't true? For this there are the \texttt{else} and \texttt{else if} statements. An \texttt{else} statement basically say what to do in all other cases (so all cases in which the test was not true). What would the value of \texttt{b} then be after the following code?
<<coop,eval=FALSE>>=
a <- 7
b <- 3
if(a == 5){
  b <- 6
} else{
  b <- 8
}
@
An alternative is the \texttt{else if} statement: it says what to do if the previous test(s) was/were not true, but some extra test is true, for example:
<<migros,eval=FALSE>>=
a <- 7
b <- 3
if(a == 5){
  b <- 6
} else if(a ==7){
  b <- 8
}
@
compare this to:
<<denner,eval=FALSE>>=
a <- 7
b <- 3
if(a == 5){
  b <- 6
} else if(a == 3){
  b <- 8
}
@
You can add in as many \texttt{else if} statements as you want, but only one \texttt{else} statement. This \texttt{else} statement will only be executed if none of the \texttt{if} and \texttt{else if} statements in the block was not executed. Can you explain what the value of \texttt{b} will be after running the following code if:
\begin{enumerate}
\item \texttt{a} is 7
\item \texttt{a} is 17
\item \texttt{a} is -3
\end{enumerate}
<<avec,eval=FALSE>>=
if(a > 10){
  b <- 6
} else if(a < 3){
  b <- 8
} else{
  b <- 7
}
@
\end{mdframed}
\subsection{Independent sequences}
In the rest of this practical, we will explore what happens if we decide to model the dynamics by randomly choosing one of the three matrices each time step. Assume an initial population of $5$ juveniles and $5$ adults. Create a matrix \texttt{N} to store the numbers that you will calculate. Now use the \texttt{sample()} function to generate a random number every time step and use this number (using \texttt{if/else}) to decide which matrix is used in a specific time step. To illustrate the use of \texttt{sample}
<<simiii>>=
sample(c(1,2,3,4),1)
@
randomly draws $1$ entry out of the vector \texttt{c(1,2,3,4)}. Now use this function to generate one possible prediction of the population dynamics until time step $50$.

<<sim_one2,echo=TRUE,eval=FALSE,out.width='0.5\\textwidth',fig.align='center'>>=
A1<-...
A2<-...
A3<-...

timesteps<-... # Total number of timesteps

N<-... # Create matrix to store the calculated values
N[,1]<-...

for(t in ...){

  test<-..... # Use sample to generate 
              # a random number (1,2,3)
  
  if(test==..){
    ...
  }else if(test==...){
    ...
  }else{
    ...
  }
}
Ntot<-colSums(N)  # Calculate total population size
                  # per timestep

plot(...)

@

<<sim_one,echo=FALSE,out.width='0.5\\textwidth',fig.align='center'>>=
timesteps<-50
N<-matrix(NA,ncol=timesteps,nrow=ncol(A))
N[,1]<-c(5,5)
for(t in 2:timesteps){

  test<-sample(c(1,2,3),1)
  
  if(test==1){
    N[,t]<-A%*%N[,t-1]
  }else if(test==2){
    N[,t]<-B%*%N[,t-1]
  }else{
    N[,t]<-C%*%N[,t-1]
  }
}
Ntot<-colSums(N)
par(mar=c(6,6,2,2))
plot(1:timesteps,Ntot,xlab="t",ylab="N",type="l")

@

You will probably notice that your result looks different from the result in the graph above. The reason for this is that the outcome depends on random numbers. It is actually not really interesting to see what one prediction tells us. Instead, write a loop that repeats the whole prediction multiple times (for example $200$ times) and plot the results of all these predictions in one graph. For this it is best to start with an empty plot and add the different realisations using the \texttt{lines()} function (see practical 7, page 20 where we used a similar approach for stochasticity in the logistic growth model). In English, what we want to do is:

\begin{enumerate}
\item Define the number of different simulations (replicates) that you want to perform
\item Create an empty plot
\item Run one of the simulations\label{steppie}
\item Use \texttt{lines()} to add a line with that outcome to the plot. Use the argument \texttt{col} to specify a color for this line. If you want to automatically generate a large number of different colors, take a look at the function \texttt{rainbow()}.
\item If you have not yet done all the simulations, return to step \ref{steppie}
\end{enumerate}
The more lines you draw on one plot, the more complicated the interpretation of the plot becomes. In order to make the interpretation a bit easier, we recommend drawing a line that corresponds to the average behaviour of all the lines. To do so, we create a vector \texttt{TotalN} at the beginning of the code (before the loops) that first contains only zeros:
<<dlin,eval=FALSE>>=
TotalN<-rep(0,timesteps)
@
at the end of the calculation of each simulation we have the vector \texttt{Ntot} that contains the simulated number of individuals at each time step. (In \texttt{Ntot}, \texttt{tot} refers to the fact that it is both the juveniles and the adults. In \texttt{TotalN}, \texttt{Total} refers to the fact that this vector contains the sum of all the different predictions), we add that line to \texttt{TotalN}:
<<dlin2,eval=FALSE>>=
TotalN<-TotalN+Ntot
@
Finally, after having calculated all the different predictions, divide \texttt{TotalN} by the number of predictions to obtain the mean behaviour. You can add this behaviour to the plot with \texttt{lines()} after the calculations have been finished. Change the \texttt{lwd} parameter to draw a thicker (more visible) line and the colour with \texttt{col=} to be able to distinguish the line. What is the trend of this average line? Is this what you expected based on the initial matrices? 


<<sim2,echo=FALSE,eval=FALSE>>=
reps<-200
timesteps<-50
threshold<-2
plot(0,0,xlim=c(0,timesteps),ylim=c(0,25),xlab="t",ylab="N",type="n")
N<-matrix(NA,ncol=timesteps,nrow=ncol(A))

extinct<-rep(0,timesteps)
meanN<-rep(0,timesteps)
N[,1]<-c(2,2)
for(rep in 1:reps){
  for(t in 2:timesteps){
    tst<-sample(c(1,2,3),1)
    
    if(sum(N[,t-1])<threshold){
      N[,t]<-0
      extinct[t]<-extinct[t]+1
    }else if(tst==1){
      N[,t]<-A%*%N[,t-1]
    }else if(tst==2){
      N[,t]<-B%*%N[,t-1]
    }else{
      N[,t]<-C%*%N[,t-1]
    }
  }
  Ntot<-colSums(N)
  lines(1:timesteps,Ntot,col=rainbow(reps)[rep])
  meanN<-meanN+(1/reps)*Ntot
}
lines(1:timesteps,meanN,lwd=6,lty=2,col="black")
plot(1:timesteps,extinct/reps,type="l")
@

<<sim,echo=FALSE,eval=FALSE>>=
reps<-200
timesteps<-50
threshold<-2
plot(0,0,xlim=c(0,timesteps),ylim=c(0,25),xlab="t",ylab="N",type="n")
N<-matrix(NA,ncol=timesteps,nrow=ncol(A))

extinct<-rep(0,timesteps)
meanN<-rep(0,timesteps)
N[,1]<-c(5,5)
for(rep in 1:reps){
  for(t in 2:timesteps){
    tst<-sample(c(1,2,3),1)
    
    if(sum(N[,t-1])<threshold){
      N[,t]<-0
      extinct[t]<-extinct[t]+1
    }else if(tst==1){
      N[,t]<-A%*%N[,t-1]
    }else if(tst==2){
      N[,t]<-B%*%N[,t-1]
    }else{
      N[,t]<-C%*%N[,t-1]
    }
  }
  Ntot<-colSums(N)
  lines(1:timesteps,Ntot,col=rainbow(reps)[rep])
  meanN<-meanN+(1/reps)*Ntot
}
lines(1:timesteps,meanN,lwd=6,lty=2,col="black")
plot(1:timesteps,extinct/reps,type="l")
@
\subsection{Temporal environmental correlations}
So far we have assumed that the chances of applying either matrix ($\boldsymbol{A_1,A_2,A_3}$) is the same. In some cases however, the conditions experienced by a population vary slowly: It is more likely that a population is exposed to similar conditions at the next time step compared to the current time step than to different conditions. In terms of matrices, this means that if at time $t$ matrix $\boldsymbol{A_1}$ is applied, it is more likely that at the next time step the same matrix is applied than that one of the other ones is used. As an example you can think of copper pollution: this pollution is expected to last multiple years, so if there is pollution this year, there will probably still be some pollution next year. Assume for example that matrix $\boldsymbol{A_3}$ describes the dynamics of the population in case of copper pollution and the population experiences this pollution at a time $t$. In this case we expect the copper pollution to still be there at time $t+1$ and therefore we assume that the chance of applying $\boldsymbol{A_3}$ at time step $t+1$ should be larger than the chance of applying one of the other two matrices that describe good conditions.

You will now incorporate this property in the model that you have already developed. The \texttt{sample()} function can be given a parameter \texttt{prob} that specifies the probability of drawing a specific number. Try this by repeatedly performing the following line:
<<probis,eval=FALSE>>=
sample(c(1,2,3),1,prob=c(4/7,2/7,1/7))
@
Now you can use this property to change the previous simulation to account for temporal auto-correlation. First, before entering the time loop (but after entering the loop that is used for calculating the different predictions), specify a new vector that will hold the probabilities. At this time (the first time point), all the matrices are still equally likely to occur.
<<aaaa>>=
probs=c(1/3,1/3,1/3)
@
Now adapt your previous code to use these probabilities to draw a new matrix every time step. Once a matrix has been drawn in a time step, change the vector \texttt{probs} such that the next time step there will be a chance of $\frac{5}{7}$ to have the same matrix again and a chance of $\frac{1}{7}$ to have either of the other matrices in the next time step. In English, what you have to do is:

\begin{enumerate}
\item Define a \texttt{probs} vector within the first loop but outside of the second. This is the vector that determines which one of the matrix is the first matrix of the time step.
\item Specify the \texttt{prob} argument of the \texttt{sample} function to be the vector \texttt{probs}.
\item After each \texttt{if/else} statements within the second loop, define a new \texttt{probs} vector which will change the probability of the matrices to be used.
\end{enumerate}
How do these predictions differ from the predictions in the non-correlated case? Does this make sense to you?
<<sim3,eval=FALSE,echo=FALSE>>=
reps<-200
timesteps<-50
threshold<-2
plot(0,0,xlim=c(0,timesteps),ylim=c(0,25),xlab="t",ylab="N",type="n")
N<-matrix(NA,ncol=timesteps,nrow=ncol(A))

extinct<-rep(0,timesteps)
meanN<-rep(0,timesteps)
N[,1]<-c(5,5)

for(rep in 1:reps){
  probs<-c(1,1,1)
  for(t in 2:timesteps){
    tst<-sample(c(1,2,3),1,prob=probs)
    if(sum(N[,t-1])<threshold){
      N[,t]<-0
      extinct[t]<-extinct[t]+1
    }else if(tst==1){
      N[,t]<-A%*%N[,t-1]
      probs<-c(5,1,1)
    }else if(tst==2){
      N[,t]<-B%*%N[,t-1]
      probs<-c(1,5,1)
    }else{
      N[,t]<-C%*%N[,t-1]
      probs<-c(1,1,5)
    }
  }
  Ntot<-colSums(N)
  lines(1:timesteps,Ntot,col=rainbow(reps)[rep])
  meanN<-meanN+(1/reps)*Ntot
}
lines(1:timesteps,meanN,lwd=6,lty=2,col="black")
plot(1:timesteps,extinct/reps,type="l")
nls(meanN~A*lambda^(1:timesteps),start=c(lambda=1.2,A=5))
@
\section{Population Viability Analysis}
What managers want to know generally is not so much the average prediction, but rather the chance of extinction. What is the chance that this population will go extinct in the next $50$ year? In order to look into this, we first need to define 'extinct': with the matrix models the vectors will never really reach $0$, but they can become really small (say a total population size of $0.001$). We thus need to decide when we call a population extinct. In this case we decide that if the population contains less than $2$ individuals, it basically went extinct. If the population size falls below this threshold, we do not actually multiply the population by the matrix, but we just set the new value of the population vector to be $\begin{pmatrix} 0 \\ 0 \end{pmatrix}$. To make the code easier to adapt, we first define a threshold variable:
<<aef,eval=FALSE>>=
threshold<-2
@
Now within the second loop and before the other statements, add an \texttt{if} statement to your code to account for this possibility. You want that if the total population size at the former time step is below the threshold, the current population size is set to $0$. 

Finally we would like to keep track of the number of extinctions over time. In order to so, create a vector \texttt{extinct} at the beginning of your code, before entering any loop:
<<aelf,eval=FALSE>>=
extinct<-rep(0,timesteps)
@
Now adapt your code such that if the population size of a specific prediction at some point in time falls below the threshold, not only the population vector is set to $\begin{pmatrix} 0 \\ 0 \end{pmatrix}$, but also the extinction is counted, that is that in that case:
<<aeaaaf,eval=FALSE>>=
extinct[t]<-extinct[t]+1
@
At the end, to find the proportion of predictions that has gone extinct, you just have to divide the vector \texttt{extinct} by the number of predictions that it is based on. If this number is large enough, the proportion of extinct predictions is the probability of extinction for that population. Implement this in the code after the loops and plot how the probability of extinction changes over time. What happens if your initial population is smaller? (for example 2 adults and 2 juveniles) What is the difference in extinction probabilities between the case of time correlated environments and time uncorrelated environments? Does this make sense to you?

If you start with a population of 5 adults and 5 juveniles and make 200 simulations, your (average) result should look similar to the following graphs (in time uncorrelated environments):
\begin{center}
\begin{tabular}{c c}
<<simop,echo=FALSE,eval=TRUE,out.width='0.40\\textwidth',results='asis'>>=
par(mar=c(6,6,2,2))
reps<-200
timesteps<-50
threshold<-2
plot(0,0,xlim=c(0,timesteps),ylim=c(0,25),xlab="t",ylab="N",type="n")
N<-matrix(NA,ncol=timesteps,nrow=ncol(A))

extinct<-rep(0,timesteps)
meanN<-rep(0,timesteps)
N[,1]<-c(5,5)
for(rep in 1:reps){
  for(t in 2:timesteps){
    tst<-sample(c(1,2,3),1)
    
    if(sum(N[,t-1])<threshold){
      N[,t]<-0
      extinct[t]<-extinct[t]+1
    }else if(tst==1){
      N[,t]<-A%*%N[,t-1]
    }else if(tst==2){
      N[,t]<-B%*%N[,t-1]
    }else{
      N[,t]<-C%*%N[,t-1]
    }
  }
  Ntot<-colSums(N)
  lines(1:timesteps,Ntot,col=rainbow(reps)[rep])
  meanN<-meanN+(1/reps)*Ntot
}
lines(1:timesteps,meanN,lwd=6,lty=2,col="black")
cat(" & ")
plot(1:timesteps,extinct/reps,type="l",xlab="t",ylab="Extinction probability")
@
\end{tabular}
\end{center}

\section{Directed environmental change}
In the last exercise this practical, we will look at the effects of an environmental driver on population dynamics, for this we use the example that Arpat showed in the lectures. 

So far we have assumed the environment to be unmeasured, however, it is possible that we actually have measured some part of the environment (e.g. temperature) and that we know how this variable affects the vital rates in the population. Here, we consider an age structured population with 3 age classes (post breeding census). Only individuals of the last age class can reproduce.
\begin{equation*}
\boldsymbol{A} = \begin{pmatrix} 0 & 0 & S_a R_a \\
S_j & 0 & 0 \\
0 & S_s & S_a\end{pmatrix}
\end{equation*}
It turns out that all functions use the logit, we will therefore first write a function to do the logit transform (don't worry about understanding this one, it is just a mathematical help)
<<tripleclass>>=
logit=function(x) 1/(1+exp(-x))
@
Now, we will write functions for each of the vital rates. The functions should take the temperature (T) as an input variable and return the value of that vital rate at the input temperature. In order to do so, we provide you with the mathematical equations that these functions are based on:
\begin{align*}
S_j (T) & = 1.2\cdot \text{logit}(-3 + 0.3\cdot T - 0.008\cdot T^2)\\
S_s (T) & = 1.7\cdot \text{logit}(-3 + 0.3\cdot T - 0.008\cdot T^2)\\
S_a (T) & = 0.9\cdot \text{logit}(-3 + 0.5\cdot T)\\
R_a(T) & = 3\cdot \text{logit}(-3 + 0.3\cdot T - 0.008\cdot T^2)
\end{align*}
Define these functions:
<<funcdef,eval=FALSE>>=
Sj <- function(Temp) ...
Ss <- ...
Sa <- ...
Ra <- ...
@
Let us check the function for juvenile survival and plot how it varies with temperature.
<<funcsies,include=FALSE>>=
temp=seq(-5,40,1)


Sj= function(temp) logit(-0.008*temp^2+0.3*temp-3)*1.2

Ss= function(temp) logit(-0.008*temp^2+0.3*temp-3)*1.7

Sa= function(temp) logit(0.5*temp-3)*0.9

Ra= function(temp) logit(-0.008*temp^2+0.3*temp-3)*3


# matplot(cbind(Sj(temp),Ss(temp),Sa(temp),Ra(temp)),type='l',lty=1,lwd=2,xlab="Temperature",ylab="Vital rate value")

# legend('topleft',c('Sj','Ss','Sa','Ra'),col=1:4,lty=1,lwd=2)

# abline(h=1,lty=2)
@

<<juvsurv>>=
# define a set of temperatures
# for which we will calculate juvenile survival
TempRange <- seq(-5,40,1)

# Calculate juvenile survival
JuvSurv <- Sj(TempRange)

# Plot the juvenile survival as a function of temperature
plot(TempRange,JuvSurv,type="l")
@
Also check if the other functions make sense over a temperature range from $-5^{\circ}$C up to $40^{\circ}$C. Next, we will need a function (let's call it MatTemp) that takes temperature as an input variable and returns the matrix for that temperature value. This function will use the functions that we have defined before. So if we type \texttt{MatTemp(5)}, we should get the $3\times 3$ population matrix in which all rates are the rates in the population at $5^\circ$C.

<<MatEnv,include=FALSE>>=

MatTemp = function(temp) matrix(c(0,Sj(temp),0,0,0,Ss(temp),Sa(temp)*Ra(temp),0,Sa(temp)),3,3)

@
We have now created all the functions that we will need. Now we have to define how are temperature varies over time. Consider for example the following 3 possibilities (here we look at temperature value at 50 different timepoints. E.g. the first entry of temp1, would be the temperature at the first time point in this scenario, the second would be the temperature at the second point in time and so on):
<<Tempsies>>=
# Scenario 1
# Temperatures are drawn from a normal distribution
# no correlation is present
temp1 <- rnorm(50,25,5)

# Scenario 2
# As with the first scenario,
# but with more variation (larger sd)
temp2 <- rnorm(50,25,15)

# Scenario 3
# Temperatures decrease over time, but some variation is still present
temp3 <- seq(30,0,length=50)+rnorm(50,0,5)
@
Now, consider a starting population of 300 individuals (100 in each age class) and use a for loop to calculate what happens to this population from time 1 to time 50. Consider plotting both the total number of individuals over time and the number of individuals per age class over time. Compare these outcomes to the patterns that Arpat showed in the lecture.
<<TheRest,include=FALSE>>=



N1=matrix(NA,3,50)

N1[,1]=c(100,100,100)

for(i in 2:50) N1[,i]=MatTemp(temp1[i])%*%N1[,i-1]

N1=rbind(N1,colSums(N1))


N2=matrix(NA,3,50)

N2[,1]=c(100,100,100)

for(i in 2:50) N2[,i]=MatTemp(temp2[i])%*%N2[,i-1]

N2=rbind(N2,colSums(N2))


N3=matrix(NA,3,50)

N3[,1]=c(100,100,100)

for(i in 2:50) N3[,i]=MatTemp(temp3[i])%*%N3[,i-1]

N3=rbind(N3,colSums(N3))



par(mfrow=c(2,3), mar=c(4,4,2,2),ps=20)

plot(temp1,type='l',col=6,ylim=c(-5,55),ylab='temperature',xlab='')

plot(temp2,type='l',col=6,ylim=c(-5,55),ylab='',xlab='')

plot(temp3,type='l',col=6,ylim=c(-5,55),ylab='',xlab='')


matplot(t(N1),type='l',lty=1,lwd=2,ylab='number of individuals',xlab='')

matplot(t(N2),type='l',lty=1,lwd=2,ylab='',xlab='time')

matplot(t(N3),type='l',lty=1,lwd=2,ylab='',xlab='')


legend('topright',c('juveniles','subadults','adults','total'),col=1:4,lty=1,lwd=2)
@
If you really want to see the difference between the three different scenarios, you would of course have to repeat the calculations many times (to make sure that you are not just having a lucky or unlucky set of temperature values). This would require writing an additional for-loop. 

The code might be cleaner by writing a function that takes a temperature scenario and a starting vector as an input and returns how the population changes over time. 

\subsection{Extra: lower level sensitivity}
Using numerical perturbations, can you calculte how sensitive $\lambda$ is to changes in temperature? Calculate $\frac{\partial \lambda}{\partial T}$ for a range of temperatures. Will changes in temperature influence $\lambda$ strongly at all temperatures? Is this a usefull calculation to begin with?
<<goater,include=FALSE,echo=FALSE>>=
sensies <- numeric(length(TempRange))
dT <- 1e-4
for(i in 1:length(TempRange)){
  Temp <- TempRange[i]
  curlam <- eigen(MatTemp(Temp))$values[1]
  chlam <- eigen(MatTemp(Temp+dT))$values[1]
  sensies[i] <- (chlam - curlam)/dT
}
plot(TempRange,sensies)
@

\section{Demographic Stochasticity (Demonstration only)}
A problem that we have not talked about so far is the fact that matrices allow for half individuals. You may for example find that the expected number of juveniles after 10 time steps equals $2.4$, but what are $0.4$ individuals? We interpret this as an 'average'. It is however also possible to take into account the fact that half an individual can not exist. For this we do not use the matrix framework, but we can use the rates that we also used in the matrix framework.

In this section we will only consider $\boldsymbol{A_1}$. That is: we have juvenile survival of $0.25$, and adult survival of $0.5$ and an average fertility rate of $2$. If we would do the matrix multiplication, we would write for the number of juveniles ($N_j$) and the number of adults ($N_a$):
\begin{align*}
N_j(t+1) &= 2\cdot N_a (t)\\
N_a(t+1) &= 0.25\cdot N_j(t) + 0.5\cdot N_a(t)
\end{align*}
This will however give rise to half individuals as well.

In order to get rid of this problem we interpret the juvenile survival rate as follows: the juvenile survival rate is the chance that an individual juvenile survives. We can simulate this in \texttt{R} with the function \texttt{rbinom(n,size,prob)}. This function simulates how many times an event occurs if we make \texttt{size} attempts and the chance of an attempt succeeding is \texttt{prob}. The element \texttt{n} specifies how many simulations of this type we want to have.

For example we have a dice with 6 sides and we want to roll it $100$ times and we want to know how many of these $100$ times the number on the dice is either $1$ or $2$. The chance of rolling either a $1$ or a $2$ is $\frac{1}{6}+\frac{1}{6}=\frac{1}{3}$, so we expect this to happen $33.3333\dots$ times if we roll the dice $100$ times. Let us simulate this in \texttt{R}:
<<dice1>>=
rbinom(n=1,size=100,prob=1/3)
@
We see that this function indeed returns us an integer number. \texttt{R} has in a sense simulated $100$ dice rolls and counted how many times the outcome was $1$ or $2$. If we let \texttt{R} simulate this experiment multiple times, we will find different outcomes:
<<dice2>>=
rbinom(n=10,size=100,prob=1/3)
@
However, if we average the outcomes of very many of these simulations, we should find back the expected $33.333\dots$:
<<dice3>>=
mean(rbinom(n=10000,size=100,prob=1/3))
@
We can now use this function to simulate the number of juveniles and adults that survive as follows:
(recall that \texttt{N[1,t]} describes the number of juveniles at time t and \texttt{N[2,t]} the number of adults at time t)
<<dice4,eval=FALSE>>=
N[2,t]<-rbinom(n=1,size=N[1,t-1],prob=0.25)
        + rbinom(n=1,size=N[2,t-1],prob=0.5)
@
Now all that is left is calculating the amount of offspring that is produced at time t. One way of doing this is by drawing a number from a Poisson distribution with $\lambda=2$. The Poisson distribution is a distribution that is frequently used for count data, but it is beyond the scope of this course to treat it in detail. To draw a number from a Poisson distribution in \texttt{R}, we use the function \texttt{rpois(n,lambda)}. Here \texttt{n} specifies the number of numbers that we want to draw from the distribution and \texttt{lambda} specifies the mean of the distribution. So to draw one number we write:
<<dice5>>=
rpois(n=1,lambda=2)
@
Let us now check whether the mean value of many numbers drawn from a Poisson distribution is indeed close to 2:
<<dice6>>=
mean(rpois(n=10000,lambda=2))
@
Finally, let us have a look at which numbers are drawn most frequently when we use a Poisson distribution:
<<dice7,out.width='0.5\\textwidth',fig.align='center',echo=c(2)>>=
par(mar=c(6,6,2,2))
hist(rpois(n=1000,lambda=2),breaks=40)
@
This function would thus describe how many offspring each adult produces. If we want to know the total number of offspring produced, we can write:
<<dice8,eval=FALSE>>=
N[1,t]<-sum(rpois(N[2,t-1],lambda=2))
@
Let us now use this to run one simulation:
<<dice9,out.width='0.5\\textwidth',fig.align='center',echo=c(-1)>>=
par(mar=c(6,6,2,2))
timesteps<-50
N<-matrix(NA,ncol=timesteps,nrow=2)

N[,1]<-c(5,5)
for(t in 2:timesteps){
    N[1,t]<-sum(rpois(N[2,t-1],lambda=2))
    N[2,t]<-rbinom(n=1,size=N[1,t-1],prob=0.25)
        + rbinom(n=1,size=N[2,t-1],prob=0.5)
}
Ntot<-colSums(N)
plot(1:timesteps,Ntot,type="l",xlab="t",ylab="N")
@
Now we repeat the simulation $200$ times and look at the results (the code is not shown, else the previous exercise would become a bit too easy...)
\begin{center}
\begin{tabular}{c c}
<<dice10,echo=FALSE,out.width='0.5\\textwidth',results='asis'>>=
par(mar=c(6,6,2,2))
reps<-200
timesteps<-50

plot(0,0,xlim=c(0,timesteps),ylim=c(0,25),xlab="t",ylab="N",type="n")
N<-matrix(NA,ncol=timesteps,nrow=ncol(A))

extinct<-rep(0,timesteps)
meanN<-rep(0,timesteps)
N[,1]<-c(5,5)
for(rep in 1:reps){
  for(t in 2:timesteps){
    N[1,t]<-sum(rpois(N[2,t-1],lambda=2))
    N[2,t]<-rbinom(n=1,size=N[1,t-1],prob=0.25)
            + rbinom(n=1,size=N[2,t-1],prob=0.5)
    if(sum(N[,t])<threshold){
      extinct[t]<-extinct[t]+1
    }
  }
    
  Ntot<-colSums(N)
  lines(1:timesteps,Ntot,col=rainbow(reps)[rep])
  meanN<-meanN+(1/reps)*Ntot  
}

lines(1:timesteps,meanN,lwd=6,lty=2,col="black")
cat(" & ")
plot(1:timesteps,extinct/reps,type="l",xlab="t",ylab="Extinction probability")
@
\end{tabular}
\end{center}
Only because we took into account demographic stochasticity, we see that the population goes extinct in $\Sexpr{round(100*extinct[timesteps]/reps,2)}\%$ of the simulations. If we compare this to the case where we have just $\boldsymbol{A_1}$ and deterministically apply this matrix every time step:
<<dice11,echo=c(-1),out.width='0.5\\textwidth',fig.align='center'>>=
par(mar=c(6,6,2,2))
A1<-matrix(c(0,0.25,2,0.5), nr=2)
timesteps<-50
N<-matrix(NA,ncol=timesteps,nrow=2)
N[,1]<-c(5,5)

for(t in 2:timesteps){
   N[,t]<-A1%*%N[,t-1]
}

Ntot<-colSums(N)
plot(1:timesteps,Ntot,type="l",xlab="t",ylab="N")
@
We see that here as expected (because $\lambda=1$) the population size stabilizes at one single value ($\Sexpr{Ntot[timesteps]}$). 

\section{Metapopulation dynamics (Not part of the course this year)}
\textbf{This year there was not enough time in the lectures to go over metapopulations. The following exercise is therefore not part of the practicals this year. (but if you're very interested you may of course try it)}
So far we have considered only populations in isolation of each other. For instance, in practical 9 we have compared two populations of yellow-necked mice, but have assumed that they were not exchanging migrants. More in general, in all matrix models so far, we have completely ignored the fact that new individuals appear in a population not only because of birth, but also because of immigration. Likewise, death is not the only factor removing individuals from a population, permanent emigration does the job as effectively. 

<<MPD0,message=FALSE,echo=FALSE>>=
B1 <- matrix(c(0,0.25,0.72,0.77),2,2,byrow=T) 
B2 <- matrix(c(0,0.32,0.74,0.79),2,2,byrow=T) 
Mj <- matrix(c(0.73,0.5,0.27,0.50),2,2,byrow=T) 
Ma <- matrix(c(0.5,0.2,0.5,.8),2,2,byrow=T)

s <- nrow(B1) # number of stages
p <- nrow(Mj) # number of patches
B <- matrix(0,p*s,p*s)
B[1:2,1:2] <- B1
B[3:4,3:4] <- B2

M <- matrix(0,p*s,p*s)
M[1:2,1:2] <- Mj
M[3:4,3:4] <- Ma

P <- matrix(0,s*p,s*p)
for (i in 1:s)
  {
	for (j in 1:p)
	  {
		E=matrix(0,s,p)
        E[i,j]<-1
        P<-P+E%x%t(E) # %x% is the Kronecker product
	  }
  }
A <- t(P)%*% M %*% P %*% B
@

\begin{figure}
\includegraphics[width=15cm]{peregrine.jpg}
\caption{\label{fig:peregrine}One of these birds is a peregrine falcon in a dive attack. The other birds are starlings and are in trouble. Populations of peregrine falcons, and other bird species, have declined during the 20th century in North America and Europe as a result of the massive use of the insecticide dichlorodiphenyltrichloroethane. DDT, which causes eggshell thinning, has now been banned from these regions but is still used in tropical regions to fight malaria. Picture by Rob Palmer.}
\end{figure}

Let us consider two populations of peregrine falcons. 
The demography of the two populations is summarized by the Leslie matrices $\boldsymbol{B_1}$ and $\boldsymbol{B_2}$ and by the associated asymptotic growth rates:
<<MPD1,echo=FALSE,results='asis',message=FALSE>>=
cat("\\begin{align*}")
cat("\\boldsymbol{B_1} &=")
 print(xtable(B1,align=rep("",ncol(B1)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("& \\boldsymbol{B_2} &=")
 print(xtable(B2,align=rep("",ncol(B1)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)

cat("\\\\ \\lambda &=",lambda(B1),"&\\lambda &=",lambda(B2))
cat("\\end{align*}")
@
One of the populations seem to be in good shape, while the other one is likely to be declining (but remember that stochasticity can make predictions based on asymptotic behaviour unreliable). Let us assume that the differences between the two populations is due to the massive use of DDT as an insecticide around population 1, while population 2 is located in a remote mountain area with less human influence.

For convenience, we can write these two matrices into a single matrix, $\boldsymbol{B}$, of dimension $4\times 4$:
<<MPD1b,echo=FALSE,results='asis',message=FALSE>>=
cat("\\begin{align*}")
cat("\\boldsymbol{B} &=")
print(xtable(B,align=rep("",ncol(B)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("\\end{align*}")
@

These two populations are not ecologically isolated, however, and they exchange a number of migrants, both juveniles and adults every year. 
Migration rates vary depending on age, and are not symmetrical. Thus, $\Sexpr{100*Mj[1,1]}\%$ of juveniles born in the population 1 stay there (and therefor $\Sexpr{100*Mj[1,2]}\%$ emigrate to population 2), while $\Sexpr{100*Mj[2,2]}\%$ of juveniles born in population 2 stay there ($\Sexpr{100*Mj[1,2]}\%$ emmigrate). 
These rates are summarized in the matrix $\boldsymbol{M_j}$:
<<MPD2,echo=FALSE,results='asis',message=FALSE>>=
cat("\\begin{align*}")
cat("\\boldsymbol{M_j} &=")
 print(xtable(Mj,align=rep("",ncol(Mj)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("\\end{align*}")
@
Similarly, migration rates for adults are summarized in matrix $\boldsymbol{M_a}$:
<<MPD2b,echo=FALSE,results='asis',message=FALSE>>=
cat("\\begin{align*}")
cat("\\boldsymbol{M_a} &=")
 print(xtable(Ma,align=rep("",ncol(Ma)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("\\end{align*}")
@

We also define a matrix $\boldsymbol{M}$ summarizing the migration rates:
<<MPD3,echo=FALSE,results='asis',message=FALSE>>=
cat("\\begin{align*}")
cat("\\boldsymbol{M} &=")
print(xtable(M,align=rep("",ncol(M)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("\\end{align*}")
@


What is the proportion of adults migrating from population 2 to population 1? (dumb question, just to check)\\

We would like to modify the matrix $\boldsymbol{B}$ so that it contains the migration rates. \\
What are the two assumptions you have to make before you can start? 
(hints: one is about population size, and one about timing)\\% even ratio of population sizes + timing of reproduction VS. migration


This task is not absolutely trivial to do mathematically because $\boldsymbol{M}$ is organized by age, while $\boldsymbol{B}$ is organized by site. 
Nevertheless, by thinking carefully, you can find what should be the elements of the matrix one by one. We just need to understand how the matrix is organized.
You can visualize four compartments in $\boldsymbol{A}$:
\begin{align*}
\boldsymbol{A}=
\begin{pmatrix}
\boldsymbol{\color{red}{A_1}} & \boldsymbol{\color{orange}{A_2}} \\
\boldsymbol{\color{blue}{A_3}} & \boldsymbol{\color{purple}{A_4}}
\end{pmatrix}
=\begin{pmatrix}
  \color{red}{a_{11}} & \color{red}{a_{12}} & \color{orange}{a_{13}} & \color{orange}{a_{14}}\\
  \color{red}{a_{21}} & \color{red}{a_{22}} & \color{orange}{a_{23}} & \color{orange}{a_{24}}\\
  \color{blue}{a_{31}} & \color{blue}{a_{32}} & \color{purple}{a_{33}} & \color{purple}{a_{34}}\\
  \color{blue}{a_{41}} & \color{blue}{a_{42}} & \color{purple}{a_{43}} & \color{purple}{a_{44}}\\
\end{pmatrix}
\end{align*}
In {\color{red}{red}}, the sub-matrix $\boldsymbol{\color{red}{A_1}}$ contains the contribution of the population $1$ to itself, that is, the fertility ($f_1$) and survival ($\phi_{j1}$ \& $\phi_{a1}$) rates, corrected for emigration out of $1$ ($d_1$). Within $\boldsymbol{\color{red}{A_1}}$, $\color{red}{a_{11}}$ is the contribution of the juvenile age class to itself, within population $1$. Clearly this is zero, for juveniles do not reproduce. $\color{red}{a_{21}}$ is the contribution of juveniles to adults, within population $1$, and is the product of juvenile survival by the proportion of non-migrating adults (not the proportion of non-migrating juveniles, because of the order of sequence of life-history events we assume). 
What are $\color{red}{a_{12}}$ and $\color{red}{a_{22}}$?\\

Let's now look at the rest of our matrix $\boldsymbol{A}$. The sub-matrix $\boldsymbol{\color{orange}{A_2}}$ represents the contributions of the population $2$ to the population $1$, that is, the fertility ($f_2$) and survival ($\phi_{j2}$ \& $\phi_{a2}$) rates within population $2$, multiplied by the rate of emigration out of $2$ ($d_2$).

You should now be able to guess the rest and write $\boldsymbol{A}$ completely, using symbols $f$ (fertility), $\phi$ (survival) and $d$ (emigration), and indexes $1$ (population $1$), $2$ (population $2$), $j$ (juvenile) and $a$ (adult).
Do it, and the proceed to the numerical application.\\


During the lectures, you have seen how one can use matrix algebra, instead of biological thinking (as you just did), to efficiently obtain this meta-population matrix $\boldsymbol{A}$, using a vec-permutation matrix, $\boldsymbol{P}$.

$\boldsymbol{P}$ can be defined as:
\begin{align*}
\boldsymbol{P} = \sum\limits_{i=1}^s  \sum\limits_{j=1}^p \boldsymbol{E_{ij}} \bigotimes \boldsymbol{E_{ij}}^T\text{, }
\end{align*}
where $s$ and $p$ are the dimensions of the two square matrices to be combined, $\bigotimes$ is the Kronecker product (google it if you don't know it, it's nothing difficult) and where $\boldsymbol{E_{ij}}$ is a matrix of dimension $s\times p$ containing a $1$ on the $i^{th}$ line of the $j^{th}$ column, and $0$ elsewhere. 
For instance, for $s=p=2$, $\boldsymbol{E_{1,2}} = \begin{pmatrix} 0 & 1 \\ 0 & 0 \end{pmatrix}$.
Can you write a code that calculates $\boldsymbol{P}$?

<<MPD4,echo=FALSE,results='asis',message=FALSE>>=
P<-matrix(0,s*p,s*p)
for (i in 1:s){
	for (j in 1:p){
		E=matrix(0,s,p)
        E[i,j]<-1
        P<-P+t(E)%x%(E) # %x% is the Kronecker product
        }}
@

From the lecture, you know that
\begin{align*}
\boldsymbol{A} = \boldsymbol{P^T}\boldsymbol{M}\boldsymbol{P}\boldsymbol{B} \text{,}
\end{align*}
where $\boldsymbol{P^T}$ is the transposition of $\boldsymbol{P}$. 
Using the English language (and not maths), describe what this formula means: What is $\boldsymbol{B}$? What means the product of $\boldsymbol{P}$ and $\boldsymbol{B}$, and so on.\\

Now write a code that applies this formula to compute $\boldsymbol{A}$. You will need to know how to multiply matrices in \texttt{R}, and you might want to know how to transpose matrices (although here it is useless because $\boldsymbol{P^T}=\boldsymbol{P}$).\\

Compute the asymptotic growth rate of $\boldsymbol{A}$. How does it compare to the local asymptotic growth rates? To their mean?\\


Let us consider another hypothetical meta-population, consisting of three very different populations. 

<<MPD6,message=FALSE,echo=FALSE>>=
B1 <- matrix(c(0,2,0.1,0.2),2,2,byrow=T) 
B2 <- matrix(c(0,0.2,0.8,0.2),2,2,byrow=T) 
B3 <- matrix(c(0,0.2,0.1,0.8),2,2,byrow=T) 
Mj <- matrix(c(0.1,0.05,0.05,0.85,0.9,0.05,0.05,0.05,0.9),3,3,byrow=T) 
Ma <- matrix(c(0.8,0.85,0.75,0.1,0.1,0.05,0.10,0.05,0.2),3,3,byrow=T)

s <- nrow(B1) # number of stages
p <- nrow(Mj) # number of patches
B <- matrix(0,p*s,p*s)
B[1:2,1:2] <- B1
B[3:4,3:4] <- B2
B[5:6,5:6] <- B3

M <- matrix(0,p*s,p*s)
M[1:3,1:3] <- Mj
M[4:6,4:6] <- Ma

P <- matrix(0,s*p,s*p)
for (i in 1:s)
  {
	for (j in 1:p)
	  {
		E=matrix(0,s,p)
        E[i,j]<-1
        P<-P+E%x%t(E) # %x% is the Kronecker product
	  }
  }
A <- t(P)%*% M %*% P %*% B

# lambda(A)
# lambda(B1)
# lambda(B2)
# lambda(B3)
@


<<MPD7,echo=FALSE,results='asis',message=FALSE>>=
cat("\\begin{align*}")
cat("\\boldsymbol{B_1} &=")
 print(xtable(B1,align=rep("",ncol(B1)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("& \\boldsymbol{B_2} &=")
 print(xtable(B2,align=rep("",ncol(B1)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("& \\boldsymbol{B_3} &=")
 print(xtable(B3,align=rep("",ncol(B1)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)

cat("\\end{align*}")
@
What are their asymptotic growth rates? What do you think about the fate of this meta-population?\\

These three populations are exchanging quite a lot of migrants, both juveniles and adults:

<<MPD8,echo=FALSE,results='asis',message=FALSE>>=
cat("\\begin{align*}")
cat("\\boldsymbol{M_j} &=")
 print(xtable(Mj,align=rep("",ncol(Mj)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("& \\boldsymbol{M_a} =")
 print(xtable(Ma,align=rep("",ncol(Ma)+1)), floating=FALSE, tabular.environment="pmatrix", 
 hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE)
cat("\\end{align*}")
@

Construct and analyze the meta-population matrix. Did you change your opinion as for the fate of the meta-population?\\

This example is obviously extreme, but it hopefully helps to demonstrate that population structure and migration can matter a lot. 

\section{Concluding remarks}

This is where our part of the practicals ends. We tried to teach you both: the basic elements of programming in \texttt{R} (for-loops, functions and if-statements) and the basic processes that may influence population dynamics. If it ends a bit too soon for you and you could think about a model that combines migration with both types of stochasticity: environmental and demographic. Alternatively, do something less biologically relevant, but quite beautiful programming wise: understand (or write) a recursive function. This is a function that calls itself, an example that draws a tree is given below. 
Finally, you could of course also consider doing a project in our research group. In our group we study both experimental systems (such as the rotifers) as well as long-term datasets (the african striped mouse, albatrosses, sheep, meerkats and many more) and we are always looking for enthusiastic students that want to explore these systems with us.

\begin{center}
Ciao!
\end{center}
<<rectree,fig.align='center',out.width='0.5\\textwidth',echo=F>>=
tree<-function(x,y,l,dir,n,nmax){ # We define a function 'tree()'
  
  # An important escape argument, leave this out and the function
  # will run forever:
  if(n==0){
    return()
  }
  
  # Picking a colour at random using the rainbow function
  # (without this the code would also work, there would just be
  # no colors)
  colour=rainbow(200,start=0.2,end=0.6,v=0.6)[round(runif(1,1,199))]
  
  # Draw a line starting a (x,y) with length 'l' and in direction
  # (in radials) dir. On top of that, we make the width of the line
  # depend on how far the branch is from the stem.
  lines(c(x,x+l*sin(dir)),c(y,y+l*cos(dir)),lwd=20*(n/nmax),col=colour)
  
  # Generate a random number that defines how many branches the tree has
  # at this point in the structure
  branches<-round(runif(1,2,4))
  
  # Now we go over the separate branches
  for(i in 1:branches){
    # to make sure not all branches point in the same direction,
    # we calculate a direction for the branch
    angle<-dir+(-pi/6)+(pi/3)*(i-1)/(branches-1)
    
    # Also, we would like the later branches to be smaller than
    # the first one:
    l2<-runif(1,0.7,0.85)*l
    
    # And finally the magic of recursion, we draw new branch with the
    # exact same function: the function 'tree'.
    tree(x+l*sin(dir),y+l*cos(dir),l2,angle,n-1,nmax)
  }
}

# Now, to actually draw the tree, we first make an empty plot
plot(0,0,type="n",xlim=c(-10,10),ylim=c(0,10),xaxt="n",yaxt="n",ylab="",xlab="")

# And then call the function tree() with the parameters we like
tree(0,0,2,0,8,8)
@

<<rectree2,fig.align='center',out.width='0.5\\textwidth',eval=FALSE>>=
tree<-function(x,y,l,dir,n,nmax){ # We define a function 'tree()'
  # x,y: start of tree, l: length of first branch, dir: direction
  # n and nmax: should be the same number: number of levels in the
  # tree.
  
  # An important escape argument, leave this out and the function
  # will run forever:
  if(n==0){
    return()
  }
  
  # Picking a colour at random using the rainbow function
  # (without this the code would also work, there would just be
  # no colors)
  pos<-round(runif(1,1,199))
  colour=rainbow(200,start=0.2,end=0.6,v=0.6)[pos]
  
  # Draw a line starting a (x,y) with length 'l' and in direction
  # (in radials) dir. On top of that, we make the width of the 
  # line depend on how far the branch is from the stem.
  lines(c(x,x+l*sin(dir)),c(y,y+l*cos(dir)),
        lwd=20*(n/nmax),col=colour)
  
  # Generate a random number that defines how many branches the 
  # tree has at this point in the structure
  branches<-round(runif(1,2,4))
  
  # Now we go over the separate branches
  for(i in 1:branches){
    # to make sure not all branches point in the same direction,
    # we calculate a direction for the branch
    angle<-dir+(-pi/6)+(pi/3)*(i-1)/(branches-1)
    
    # Also, we would like the later branches to be smaller than
    # the first one:
    l2<-runif(1,0.7,0.85)*l
    
    # And finally the magic of recursion, we draw the new branch
    # simply by using theexact same function: the function 'tree'.
    tree(x+l*sin(dir),y+l*cos(dir),l2,angle,n-1,nmax)
  }
}

# Now, to actually draw the tree, we first make an empty plot
plot(0,0,type="n",xlim=c(-10,10),ylim=c(0,10),
     xaxt="n",yaxt="n",ylab="",xlab="")

# And then call the function tree() with the parameters we like
tree(0,0,2,0,8,8)
@
\end{document}