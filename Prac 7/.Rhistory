n[,t+1] <- A%*%n[,t]      # %*% = matrix multiplication in R
N[t+1] <- sum(n[,t+1])
}
n
N
# Define parameters
f1 <- 1.5
f2 <- 3
s0 <- 0.2
s1 <- 0.5
s2 <- 0.65
# Create the pre birth-pulse swallow matrix population model
A <- matrix(c(
s0*f1, s0*f2,
s1,    s2), nrow = 2, byrow = TRUE)
tspan <- 20                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
N <- matrix(0,tspan,1)        # storage of total abundance
gr <- matrix(0,tspan-1,1)     # storage of time-specific population growth rates
n[,1] <- c(10,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <- A%*%n[,t]      # %*% = matrix multiplication in R
N[t+1] <- sum(n[,t+1])
gr[t] <- sum(n[,t+1])/sum(n[,t])  # per time step population growth rate
}
n
N
A<-matrix(c(F0, F1, F2, F3, P01, 0, 0, 0, 0, P12, 0, 0, 0, 0, P23, 0, 0, 0, P34), nr=4, byrow=TRUE)
A<-matrix(c(F1, F2, F3, F4, P01, 0, 0, 0, 0, P12, 0, 0, 0, 0, P23, 0, 0, 0, 0, P34), nr=4, byrow=TRUE)
A<-matrix(c(F1, F2, F3, F4, P01, 0, 0, 0, 0, P12, 0, 0, 0, 0, P23, 0, 0, 0, 0, P34), nrow=4, byrow=TRUE)
n1<-n0%*%A
n1
n11<- 10
n12<- 0
n13<- 0
n14<- 0
n0<-c(n11, n12, n13, n14)
n1<-n0%*%A
nt2<-A%*%n0
for (t in 1:(tspan-1)) {
n[,t+1] <- n[,t]%*%A      # %*% = matrix multiplication in R
N[t+1] <- sum(n[,t+1])
}
tspan <- 4                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
N <- matrix(0,tspan,1)        # storage of total abundance
n[,1] <- c(10,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <- n[,t]%*%A      # %*% = matrix multiplication in R
N[t+1] <- sum(n[,t+1])
}
n1
A
A<-matrix(c(F1, F2, F3, F4, P01, 0, 0, 0, 0, P12, 0, 0, 0, 0, P23, 0, 0, 0, 0, P34), nrow=4, byrow=TRUE)
A
A<-matrix(c(F1, F2, F3, F4, P01, 0, 0, 0, 0, P12, 0, 0, 0, 0, P23, 0, 0, 0, 0, P34), nrow=4)
A
A<-matrix(c(F1, F2, F3, F4, P01, 0, 0, 0, 0, P12, 0, 0, 0, 0, P23, 0, 0, 0, 0, P34), nr=4)
A
F1<- 1.60
F2<- 1.50
F3<- 0.25
F4<- 0
A<-matrix(c(F1, F2, F3, F4, P01, 0, 0, 0, 0, P12, 0, 0, 0, 0, P23, 0, 0, 0, 0, P34), nr=4)
A
A<-matrix(c(F1, P01, 0, 0, F2, 0, P12, 0, F3, 0, 0, P23, F4,0,0,P34), nr=4)
A
n11<- 10
n12<- 0
n13<- 0
n14<- 0
n0<-c(n11, n12, n13, n14)
n1<-n0%*%A
tspan <- 4                         # time span for projections
rows <- dim(A)[1]
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
N <- matrix(0,tspan,1)        # storage of total abundance
n[,1] <- c(10,0,0,0)              # initial population abundance in each age class
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
N[t+1] <- sum(n[,t+1])
}
n
N
16+1.6
8+1.6
16*1.6
8*1.5
16*0.8
13*0.5
26+12
38*0.8
log(0)
tempdir()
N_0<-Bea$Population[1]
N_0
Nt<-Bea$Population[length(Bea$Population)]
Nt
View(Bea)
An alternative to find the function describing the growth of this population is to go from the average growth rate which we will call $R$. In the section \textit{Average growth rate}, we showed that the average growth rate is given by $R=\frac{N_t}{N_0}$. The code \texttt{length} gives the number of elements of the object it is applied to. Run separately the different parts of the code below to find out what they do.
<<t27,echo=T,eval=T, results='hide'>>=
N0<-Bea$Population[1]
Nt<-Bea$Population[length(Bea$Population)]
lambda<-(N0/Nt)^(1/length(Bea$Population))
lambda
@
length(Bea$Population)
16*1.6
8*1.5
16*0.8
26+12
38*1.6
13*1.5
61+19+1
38*0.8
13*0.5
install.packages("xtable")
plot(n[,1])
tspan <- 4                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(n[1,])
plot(n[1,])
plot(n[1,], type="l")
line(n[2,], typle="l")
line(n[2,])
aline(n[2,])
abline(n[2,])
lines(n[2,])
lines(n[3,])
lines(n[4,])
lines(n[3,])
plot(n[1,], type="l", ylim=(0, 100))
lines(n[2,])
plot(n[1,], type="l", ylim=v(0, 100))
plot(n[1,], type="l", ylim=(0, 100))
plot(n[1,], type="l", ylim=(0:100))
lines(n[2,])
lines(n[3,])
lines(n[4,])
plot(n[1,], type="l", ylim=(0:100))
plot(n[1,], type="l", ylim=(0 100))
plot(n[1,], type="l", ylim=(0; 100))
plot(n[1,], type="l", ylim=(0, 100))
plot(n[1,], type="l", ylim=c(0, 100))
lines(n[2,])
lines(n[3,])
lines(n[4,])
tspan <- 400                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(n[1,], type="l", ylim=c(0, 100))
lines(n[2,])
lines(n[3,])
lines(n[4,])
@
plot(n[1,], type="l", ylim=c(0,10000))
lines(n[2,])
lines(n[3,])
lines(n[4,])
tspan <- 20                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(n[1,], type="l", ylim=c(0,10000))
lines(n[2,])
lines(n[3,])
lines(n[4,])
plot(log(n[1,]), type="l", ylim=c(0,10000))
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l", ylim=c(0,10))
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l", ylim=c(0,20))
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
@
plot(log(n[1,]), type="l")
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
@
tspan <- 10                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(log(n[1,]), type="l")
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
tspan <- 5                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(log(n[1,]), type="l")
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l")
lines(log(n[2,]), color="blue")
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l")
lines(log(n[2,]), col="blue")
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l", col="blue")
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
lines(log(n[4,]), col="pink")
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5))
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="pink")
@
lines(log(n[4,]), col="purple")
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5))
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,2,1,2),
col=c("blue", "red", "green", "purple"))
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5), xlab="year", ylab="$\ln(n(t))$")
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,2,1,2),
col=c("blue", "red", "green", "purple"))
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5), xlab="year", ylab="$ln(n(t))$")
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,2,1,2),
col=c("blue", "red", "green", "purple"))
n
tspan <- 6                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5), xlab="year", ylab="$ln(n(t))$") #please add slash!
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,1,1,1),
col=c("blue", "red", "green", "purple"))
@
tspan <- 10                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
plot(log(n[1,]), type="l", col="blue", ylim=c(0,10), xlab="year", ylab="$ln(n(t))$") #please add slash!
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,1,1,1),
col=c("blue", "red", "green", "purple"))
colSums (n, na.rm = FALSE, dims = 1)
Ntot<-colSums (n, na.rm = FALSE, dims = 1)
Ntot<-colSums (n,)
Ntot<-colSums (n)
Ntot
plot(Ntot)
plot(Ntot, type="l", xlab="year", ylab="N(t)")
gr <- sum(n[,i])/sum(n[,t-1]
gr <- sum(n[,i])/sum(n[,t-1])
gr <- sum(n[,i])/sum(n[,t-1])
gr
Ntot<-colSums (n)
Ntot
gr <- sum(n[,i])/sum(n[,i-1])
gr
N0<-n[1,1]
N0
N0<-Ntot[1,1]
N0
N0<-Ntot[,1]
N0<-Ntot[1]
N0
Nt<-Ntot[length(Ntot)]
Nt
N0<-Ntot[1]
Nt<-Ntot[length(Ntot)]
lambda<-(Nt/N0)^(1/((length(Ntot)-1))
lambda
lambda<-(Nt/N0)^(1/((length(Ntot)-1)))
lambda
eigen(A)
eigens.A<-eigen(A)
eigens.A [1,]
eigens.A$values
lambda<-which.max(eigens.A$values)
lambda
position<-which.max(eigens.A$values)
position
lambda2<-eigens.A$values[,position]
lambda2<-eigens.A$values[position,]
lambda2<-eigens.A$values[position]
lambda2
library(popbiol)
library(popbio)
library(biopop)
install.packages("popbio")
library(popbio)
lambda(A)
lambda1
lambda1<-(Nt/N0)^(1/((length(Ntot)-1)))
lambda1
eigen
eigens.A
rev<-eigens.A$vector[position]
rev
rev<-eigens.A$vector[,position]
rev
ssd<-w/sum(w)
w<-eigens.A$vector[,position]
w
ssd<-w/sum(w)
ssd
round(ssd[1]),2
round(ssd[1],2)
# Build the Leslie Matrix for the barn owl population
F11<- 1.60+0.01
F21<- 1.50
F31<- 0.25
F41<- 0
P11<- 0.80
P21<- 0.5
P31<- 0.25
P41<- 0
A1<-matrix(c(F11,P11,0,0,F21,0,P21,0,F31,0,0,P31,F41,0,0,P41), nr=4)
A1
lambdaF1<- lambda(A1)
lambdaF1
F11<- 1.60
F21<- 1.50+0.01
F31<- 0.25
F41<- 0
P11<- 0.80
P21<- 0.5
P31<- 0.25
P41<- 0
A2<-matrix(c(F11,P11,0,0,F21,0,P21,0,F31,0,0,P31,F41,0,0,P41), nr=4)
A2
lambdaF2<- lambda(A2)
lambdaF1
lambdaF2
F11<- 1.60
F21<- 1.50
F31<- 0.25+0.01
F41<- 0
P11<- 0.80
P21<- 0.5
P31<- 0.25
P41<- 0
A3<-matrix(c(F11,P11,0,0,F21,0,P21,0,F31,0,0,P31,F41,0,0,P41), nr=4)
lambdaF3<- lambda(A3)
lambdaF1
lambdaF2
lambdaF3
sensitivity(A)
lambda(A)
(lambda-lambdaF1)/0.01
(lambdaF1-lambda)/0.01
lambdaF1
lambda
(lambdaF1-lambda(A))/0.01
sensitivity(A)
N1<-300
rd<-0.2
K<-400
N2 <- N1*exp(rd*(1-N1/K))
N3 <- N2*exp(rd*(1-N2/K))
N4 <- N3*exp(rd*(1-N3/K))
cat("$N_2 = ",N2,"$\\\\$N_3 = ",N3,"$\\\\$N_4 = ",N4,"$")
N2
N3
N4
N1*exp(rd*(1-(N1/K)))
Ricker <- function(r,t=400,K=400,N0=50){
N <- numeric(t)
N[1] <- N0
for(i in 2:t){
N[i] <- N[i-1] * exp(r*(1-N[i-1]/K))
}
range(N[(t-20):t])
}
Rs <- seq(0.1,4,0.1)
lapply(Rs, Ricker)
tapply(Rs, Ricker)
vapply(Rs, Ricker)
sapply(Rs, Ricker)
Res <- sapply(Rs, Ricker)
Res
Rs <- seq(-2,2,0.1)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Res[2,])
Res
Rs <- seq(-2,2,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Res[2,])
Rs <- seq(-2,4,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Res[2,])
Res
Rs <- seq(-2,4,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Rs,Res[2,])
Rs <- seq(0,3,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Rs,Res[2,])
Rs <- seq(0.1,3,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Rs,Res[2,])
Rs <- seq(0.1,3,0.05)
Res <- sapply(Rs, FUN = function(x) Ricker(x,K=100))
plot(Rs,Res[1,],type="l",xlab="r")
lines(Rs,Res[2,])
Res
plot(Rs,Res[1,],type="l",xlab="r",ylim=c(0,230))
lines(Rs,Res[2,])
