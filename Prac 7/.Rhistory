N0<-Bea$Population[1]
Nt<-Bea$Population[length(Bea$Population)]
lambda<-(N0/Nt)^(1/length(Bea$Population))
lambda
@
length(Bea$Population)
16*1.6
8*1.5
16*0.8
26+12
38*1.6
13*1.5
61+19+1
38*0.8
13*0.5
install.packages("xtable")
plot(n[,1])
tspan <- 4                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(n[1,])
plot(n[1,])
plot(n[1,], type="l")
line(n[2,], typle="l")
line(n[2,])
aline(n[2,])
abline(n[2,])
lines(n[2,])
lines(n[3,])
lines(n[4,])
lines(n[3,])
plot(n[1,], type="l", ylim=(0, 100))
lines(n[2,])
plot(n[1,], type="l", ylim=v(0, 100))
plot(n[1,], type="l", ylim=(0, 100))
plot(n[1,], type="l", ylim=(0:100))
lines(n[2,])
lines(n[3,])
lines(n[4,])
plot(n[1,], type="l", ylim=(0:100))
plot(n[1,], type="l", ylim=(0 100))
plot(n[1,], type="l", ylim=(0; 100))
plot(n[1,], type="l", ylim=(0, 100))
plot(n[1,], type="l", ylim=c(0, 100))
lines(n[2,])
lines(n[3,])
lines(n[4,])
tspan <- 400                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(n[1,], type="l", ylim=c(0, 100))
lines(n[2,])
lines(n[3,])
lines(n[4,])
@
plot(n[1,], type="l", ylim=c(0,10000))
lines(n[2,])
lines(n[3,])
lines(n[4,])
tspan <- 20                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(n[1,], type="l", ylim=c(0,10000))
lines(n[2,])
lines(n[3,])
lines(n[4,])
plot(log(n[1,]), type="l", ylim=c(0,10000))
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l", ylim=c(0,10))
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l", ylim=c(0,20))
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
@
plot(log(n[1,]), type="l")
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
@
tspan <- 10                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(log(n[1,]), type="l")
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
tspan <- 5                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
n
plot(log(n[1,]), type="l")
lines(log(n[2,]))
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l")
lines(log(n[2,]), color="blue")
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l")
lines(log(n[2,]), col="blue")
lines(log(n[3,]))
lines(log(n[4,]))
plot(log(n[1,]), type="l", col="blue")
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
lines(log(n[4,]), col="pink")
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5))
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="pink")
@
lines(log(n[4,]), col="purple")
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5))
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,2,1,2),
col=c("blue", "red", "green", "purple"))
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5), xlab="year", ylab="$\ln(n(t))$")
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,2,1,2),
col=c("blue", "red", "green", "purple"))
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5), xlab="year", ylab="$ln(n(t))$")
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,2,1,2),
col=c("blue", "red", "green", "purple"))
n
tspan <- 6                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
plot(log(n[1,]), type="l", col="blue", ylim=c(0,5), xlab="year", ylab="$ln(n(t))$") #please add slash!
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,1,1,1),
col=c("blue", "red", "green", "purple"))
@
tspan <- 10                         # time span for projections
rows <- dim(A)[1]
# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance
n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class
# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
}
plot(log(n[1,]), type="l", col="blue", ylim=c(0,10), xlab="year", ylab="$ln(n(t))$") #please add slash!
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
c("age class 1 ","age class 2", "age class 3", "age class 4"),
bty = "n",
lty=c(1,1,1,1),
col=c("blue", "red", "green", "purple"))
colSums (n, na.rm = FALSE, dims = 1)
Ntot<-colSums (n, na.rm = FALSE, dims = 1)
Ntot<-colSums (n,)
Ntot<-colSums (n)
Ntot
plot(Ntot)
plot(Ntot, type="l", xlab="year", ylab="N(t)")
gr <- sum(n[,i])/sum(n[,t-1]
gr <- sum(n[,i])/sum(n[,t-1])
gr <- sum(n[,i])/sum(n[,t-1])
gr
Ntot<-colSums (n)
Ntot
gr <- sum(n[,i])/sum(n[,i-1])
gr
N0<-n[1,1]
N0
N0<-Ntot[1,1]
N0
N0<-Ntot[,1]
N0<-Ntot[1]
N0
Nt<-Ntot[length(Ntot)]
Nt
N0<-Ntot[1]
Nt<-Ntot[length(Ntot)]
lambda<-(Nt/N0)^(1/((length(Ntot)-1))
lambda
lambda<-(Nt/N0)^(1/((length(Ntot)-1)))
lambda
eigen(A)
eigens.A<-eigen(A)
eigens.A [1,]
eigens.A$values
lambda<-which.max(eigens.A$values)
lambda
position<-which.max(eigens.A$values)
position
lambda2<-eigens.A$values[,position]
lambda2<-eigens.A$values[position,]
lambda2<-eigens.A$values[position]
lambda2
library(popbiol)
library(popbio)
library(biopop)
install.packages("popbio")
library(popbio)
lambda(A)
lambda1
lambda1<-(Nt/N0)^(1/((length(Ntot)-1)))
lambda1
eigen
eigens.A
rev<-eigens.A$vector[position]
rev
rev<-eigens.A$vector[,position]
rev
ssd<-w/sum(w)
w<-eigens.A$vector[,position]
w
ssd<-w/sum(w)
ssd
round(ssd[1]),2
round(ssd[1],2)
# Build the Leslie Matrix for the barn owl population
F11<- 1.60+0.01
F21<- 1.50
F31<- 0.25
F41<- 0
P11<- 0.80
P21<- 0.5
P31<- 0.25
P41<- 0
A1<-matrix(c(F11,P11,0,0,F21,0,P21,0,F31,0,0,P31,F41,0,0,P41), nr=4)
A1
lambdaF1<- lambda(A1)
lambdaF1
F11<- 1.60
F21<- 1.50+0.01
F31<- 0.25
F41<- 0
P11<- 0.80
P21<- 0.5
P31<- 0.25
P41<- 0
A2<-matrix(c(F11,P11,0,0,F21,0,P21,0,F31,0,0,P31,F41,0,0,P41), nr=4)
A2
lambdaF2<- lambda(A2)
lambdaF1
lambdaF2
F11<- 1.60
F21<- 1.50
F31<- 0.25+0.01
F41<- 0
P11<- 0.80
P21<- 0.5
P31<- 0.25
P41<- 0
A3<-matrix(c(F11,P11,0,0,F21,0,P21,0,F31,0,0,P31,F41,0,0,P41), nr=4)
lambdaF3<- lambda(A3)
lambdaF1
lambdaF2
lambdaF3
sensitivity(A)
lambda(A)
(lambda-lambdaF1)/0.01
(lambdaF1-lambda)/0.01
lambdaF1
lambda
(lambdaF1-lambda(A))/0.01
sensitivity(A)
N1<-300
rd<-0.2
K<-400
N2 <- N1*exp(rd*(1-N1/K))
N3 <- N2*exp(rd*(1-N2/K))
N4 <- N3*exp(rd*(1-N3/K))
cat("$N_2 = ",N2,"$\\\\$N_3 = ",N3,"$\\\\$N_4 = ",N4,"$")
N2
N3
N4
N1*exp(rd*(1-(N1/K)))
Ricker <- function(r,t=400,K=400,N0=50){
N <- numeric(t)
N[1] <- N0
for(i in 2:t){
N[i] <- N[i-1] * exp(r*(1-N[i-1]/K))
}
range(N[(t-20):t])
}
Rs <- seq(0.1,4,0.1)
lapply(Rs, Ricker)
tapply(Rs, Ricker)
vapply(Rs, Ricker)
sapply(Rs, Ricker)
Res <- sapply(Rs, Ricker)
Res
Rs <- seq(-2,2,0.1)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Res[2,])
Res
Rs <- seq(-2,2,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Res[2,])
Rs <- seq(-2,4,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Res[2,])
Res
Rs <- seq(-2,4,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Rs,Res[2,])
Rs <- seq(0,3,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Rs,Res[2,])
Rs <- seq(0.1,3,0.05)
Res <- sapply(Rs, Ricker)
plot(Rs,Res[1,],type="l",xlab="r")
lines(Rs,Res[2,])
Rs <- seq(0.1,3,0.05)
Res <- sapply(Rs, FUN = function(x) Ricker(x,K=100))
plot(Rs,Res[1,],type="l",xlab="r")
lines(Rs,Res[2,])
Res
plot(Rs,Res[1,],type="l",xlab="r",ylim=c(0,230))
lines(Rs,Res[2,])
Np <- 1000
outcome_10 <- rep(0,Np)
outcome_1000 <- rep(0,Np)
for(i in 1:Np){
outcome_10[i] <- sum( runif(10) < 0.6) / 10
outcome_1000[i] <- sum( runif(1000) < 0.6) / 1000
}
hist(outcome_10)
hist(outcome_1000)
hist(outcome_10,xlim=c(0,1))
hist(outcome_1000,xlim=c(0,1))
Np <- 1000
outcome_10 <- rep(0,Np)
outcome_100 <- rep(0,Np)
for(i in 1:Np){
outcome_10[i] <- sum( runif(10) < 0.6) / 10
outcome_100[i] <- sum( runif(100) < 0.6) / 100
}
hist(outcome_10,xlim=c(0,1))
hist(outcome_100,xlim=c(0,1))
A<-matrix(runif(4),ncol=2)
eigen(A)$value[1]
A
A<-matrix(runif(6),ncol=2)
eigen(A)
sens <- function(A){
da <- 1e-4
lam <- eigen(A)$value[1]
dim <- ncol(A)
output <- matrix(NA,ncol=dim,nrow=dim)
for(i in 1:nrow(A)){
for(j in 1:ncol(A)){
TempA <- A
TempA[i,j] <- A[i,j] + da
TemLam <- eigen(A)$value[1]
output[i,j] <- (TemLam - lam) /da
}
}
return(output)
}
sens(A)
A<-matrix(runif(4),ncol=2)
sens(A)
A<-matrix(runif(4),ncol=2)
sens <- function(A){
da <- 1e-4
lam <- eigen(A)$value[1]
dim <- ncol(A)
output <- matrix(NA,ncol=dim,nrow=dim)
for(i in 1:nrow(A)){
for(j in 1:ncol(A)){
TempA <- A
TempA[i,j] <- A[i,j] + da
TemLam <- eigen(TempA)$value[1]
output[i,j] <- (TemLam - lam) /da
}
}
return(output)
}
sen(A)
sens(A)
library(popbio)
sensitivity(A)
eigen(A)$vector
eigen(t(A))$vector[,1]
eigen(A)$vector[,1]
v <- eigen(A)$vector[,1]
w <- eigen(t(A))$vector[,1]
sens <- function(A){
v <- eigen(A)$vector[,1]
w <- eigen(t(A))$vector[,1]
v %*% t(w) / (t(w)%*%v)
}
sens(A)
v <- eigen(A)$vector[,1]
w <- eigen(t(A))$vector[,1]
v %*% t(w)
(t(w)%*%v)
sens <- function(A){
v <- eigen(A)$vector[,1]
w <- eigen(t(A))$vector[,1]
v %*% t(w) / as.numeric(t(w)%*%v)
}
sens(A)
sensitivity(A)
v
w
t(v)
t(t(v))
v <- eigen(A)$vector[,1,drop=FALSE]
w <- eigen(t(A))$vector[,1,drop=FALSE]
v %*% t(w) / as.numeric(t(w)%*%v)
sensitivity(A)
v
w
t(w)%*%v
v %*% t(w) / as.numeric(v%*%w)
w <- eigen(A)$vector[,1]
v <- eigen(t(A))$vector[,1]
v %*% t(w) / as.numeric(t(w)%*%v)
sensitivity(A)
A <- matrix(runif(9),ncol=3)
w <- eigen(A)$vector[,1]
v <- eigen(t(A))$vector[,1]
v %*% t(w) / as.numeric(t(w)%*%v)
sensitivity(A)
v
w <- eigen(A)$vector[,1]
v <- eigen(t(A))$vector[,1]
t(w)%*%v
as.numeric(t(w)%*%v)
