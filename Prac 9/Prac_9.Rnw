\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
%\usepackage{bbold}
\usepackage{tikz}
%\usepackage{silence}
\usepackage{mdframed}
%\WarningFilter{mdframed}{You got a bad break}
\usepackage[colorinlistoftodos]{todonotes}
%\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{color}
\colorlet{exampcol}{blue!10}
\usepackage{multicol}
\usepackage[answerdelayed]{exercise}
\usepackage{booktabs}
\usepackage{caption}

\title{BIO311: Population Ecology\\ \textit{Prac 9: Population Matrices \& LTRE}}

\setcounter{tocdepth}{1} % Determines the depth of the table of contents;; 0:chapters, 1: chapters and sections, 2: chapters,sections and subsections

%\renewcommand{\theExercise}{\thechapter.\arabic{Exercise}}%

\begin{document}
\input{../authors}
<<setup, cache=FALSE, include=FALSE>>=
opts_chunk$set(dev="tikz",tidy=F,dev.args=list(pointsize=7.5))
options(width=60)

@

<<setparameters,echo=FALSE,include=FALSE>>=

@
\maketitle
\tableofcontents
\vspace{3cm}
\newpage

\subsubsection{Reproductive values}\label{Newfrhere}
The reproductive value vector represents the contribution of each individual to present and future reproduction. In other words, it gives how much an individual in a given age class contributes to the population on the long-term, including offspring of its offspring. That is: if we have a population and its matrix at time $t=1$, what proportion of individuals at a much later time will be descendants of individuals in age class $1$ at time $t=1$ and how many from individuals in age class $2$ etc. Mathematically, the reproductive value vector is the left eigenvector of the population matrix.
\begin{equation}
\vec{v}A=\lambda \vec{v}
\end{equation}
Please note that this time the vector is on the left side instead of on the right side of the matrix. This is why this is called a left eigenvector. Multiplication with the vector on the left side of the matrix looks as follows in 2 dimensions:
\begin{equation}
\begin{pmatrix} v_1 & v_2 \end{pmatrix} \begin{pmatrix} a_{1,1} & a_{1,2}\\ a_{2,1} & a_{2,2} \end{pmatrix} = \begin{pmatrix} v_1 a_{1,1} + v_2 a_{2,1} & v_1 a_{1,2} + v_2 a_{2,2} \end{pmatrix}
\end{equation}
Again, we take the row from the first element (in this case the vector) and multiply its elements by the elements of the first column of the second element (in these case a matrix). Adding up these contributions gives us the value for the first entry of the final vector. Compare this to what you would get if the order of the matrix and the vector would be the other way around.

To get the left eigenvector of a matrix, we need to perform the eigen analysis on the transpose of the projection matrix. (The transpose of a matrix is the matrix we get by exchanging the rows and the columns of that matrix. For example for the matrix $\boldsymbol{B}=\begin{pmatrix}a & b\\ c & d\end{pmatrix}$, $\boldsymbol{B}^T$ is the transpose of matrix $\boldsymbol{B}$ and $\boldsymbol{B}^T=\begin{pmatrix}a & c\\ b & d\end{pmatrix}$). More visually: when you transpose a matrix, you mirror its elements in the diagonal of that matrix. \texttt{t()} is the \texttt{R} function that transposes a matrix. If you do not remember what the function \texttt{eigen} does, reread the subsection \textit{asymptotic rate of increase} or aks \texttt{R} (\texttt{?eigen}).

<<t18,echo=T,eval=T, results='hide'>>=
At<-t(A)
eigens.At<-eigen(At)
eigens.At
@
We apply the same proceedure as for the right eigenvector to find the left eigenvector and the eigenvalue. Write the code to extract the eigenvalue and the left eigenvector. Do you notice anything about the eigenvalue? Check that the found dominant left eigenvector is indeed a left eigenvector of the matrix with the dominant eigenvalue as its eigenvalue.\\[1.5ex]
<<t19,echo=F,eval=T, results='hide'>>=
position3<-which.max(eigens.At$values)
lambda3<-eigens.At$values[position3]
v<-eigens.At$vector[,position3]
rv<-v/sum(v)
rv
@
\begin{mdframed}
\textbf{Additional information: Reproductive values more in depth}\\
If you want to understand the interpretation of the reproductive values more closely, take a look at the following (not too elegant) code:
<<testcode>>=
B<-matrix(4*runif(9),nrow=3) # We generate a random matrix

B 
# We output B, in case you want to repeat the 
# simulation yourself

eigen(t(B))$vectors[,1]/sum(eigen(t(B))$vectors[,1])
# We calculate the dominant left eigenvector of this matrix
# and normalise it with respect to the sum of its elements

# Now we want to investigate what would happen to the 
# following 3 initial populations:
# 1) (1,0,0)  2) (0,1,0)  3) (0,0,1)

N1<-rep(NA,3)
# Create an empty vector for storing the final population
# size if we start with any of the three initial populations
for(i in 1:3){
  N<-rep(0,3)
  N[i]<-1
  # Set the initial population vector
  # the first time it will be (1,0,0)
  # then (0,1,0) and finally (0,0,1)
  
  for(t in 1:40){ 
    # we project the population for 40 timesteps
    N<-B%*%N
  }
  N1[i]<-sum(N)
  # We store the total population size after 40 timesteps
  # in the vector N1
}
N1/sum(N1)
# We output the normalised version of N1, which should be
# equal to the left eigenvector, do check this!
@
You can interpret this as follows: if we for example start with a population $\begin{pmatrix}1\\ 1\\ 1 \end{pmatrix}$, after $40$ years, $\Sexpr{100*round(N1[1]/sum(N1),2)}\% $ of the total population will have originated from the individual that was initially in age class $1$, $\Sexpr{100*round(N1[2]/sum(N1),2)}\% $ from the individual in age class $2$ and the remaining $\Sexpr{100*round(N1[3]/sum(N1),2)}\% $ of the total population at timestep $40$ from the individual that was in age class $3$ in the initial population.
\textit{Please note that since we took completely random numbers to construct the matrix, the matrix is unlikely to have biological relevance. But the concept of course remains the same for more relevant matrices.}\\[1.5ex]
However, what would happen if the initial population would look as follows: $\begin{pmatrix}2\\ 1\\ 1 \end{pmatrix}$? If we project this initial population in the future we find (the code is omitted this time):
<<testcode2,echo=FALSE>>=

# We calculate the dominant left eigenvector of this matrix
# and normalise it with respect to the sum of its elements

# Now we want to investigate what would happen to the 
# following initial populations:
# 1) (1,0,0)
# 2) (0,1,0)
# 3) (0,0,1)

N1<-rep(NA,3)
# Create an empty vector for storing the final population
# size if we start with any of the three initial populations
for(i in 1:3){
  
  N<-rep(0,3)
  N[i]<-1
  if(i==1){
    N[i]<-2
  }
  # Set the initial population vector
  # the first time it will be (1,0,0)
  # then (0,1,0) and finally (0,0,1)
  
  for(t in 1:40){ 
    # we project the population for 40 timesteps
    N<-B%*%N
  }
  
  N1[i]<-sum(N)
  # We store the total population size after 40 timesteps
  # in the vector N1
}
N1/sum(N1)
# We output the normalised version of N1, which should be
# equal to the left eigenvector, do check this!
@
This means that after $40$ years, $\Sexpr{100*round(N1[1]/sum(N1),2)}\% $ of the total population will have originated from the two individuals that were initially in age class $1$, $\Sexpr{100*round(N1[2]/sum(N1),2)}\% $ from the individual in age class $2$ and the remaining $\Sexpr{100*round(N1[3]/sum(N1),2)}\% $ of the total population at timestep $40$ from the individual that was in age class $3$ in the initial population. These numbers do not correspond to the left eigenvector, yet they do relate to the left eigenvalue.
First we need to realize that if $\Sexpr{100*round(N1[1]/sum(N1),2)}\% $ of the final population originated from the two individuals in age class 1 in the initial population, this means that each of these two individuals is responsible for $\Sexpr{50*round(N1[1]/sum(N1),2)}\% $ of the final population. It is of course fairer to compare these numbers with each other (so after correcting for the number of individuals that we started with):
\begin{equation*}
\begin{pmatrix}
\Sexpr{50*round(N1[1]/sum(N1),2)} \\
\Sexpr{100*round(N1[2]/sum(N1),2)} \\
\Sexpr{100*round(N1[3]/sum(N1),2)}
\end{pmatrix}
\end{equation*}
However, now the numbers no longer add up to $100\%$. Since all we care about is the ratio between the different contributions, we can just divide all of them by the sum of the three contributions ($\approx \Sexpr{50*round(N1[1]/sum(N1),2)} +\Sexpr{100*round(N1[2]/sum(N1),2)} + \Sexpr{100*round(N1[3]/sum(N1),2)} $) and multiply the total by $100$ (just to make sure that all the percentages add up to $100$). What we get now is: 
\begin{equation*}
\begin{pmatrix}
\Sexpr{round(50*N1[1]/(0.5*N1[1]+N1[2]+N1[3]),2)} \\
\Sexpr{round(100*N1[2]/(0.5*N1[1]+N1[2]+N1[3]),2)} \\
\Sexpr{round(100*N1[3]/(0.5*N1[1]+N1[2]+N1[3]),2)}
\end{pmatrix}
\end{equation*}
This is indeed again the left eigenvector! (Hopefully. Every time we save this document new random numbers are generated, so actually we can only hope that the theory is general enough to work for all random matrices \texttt{B} that are accidentally generated...). We see thus that the left eigenvector actually mainly tell you how many more offspring an individual that starts in a certain age class will have compared to individuals in other age classes on the long term. -- This is indeed a relatively difficult concept, but maybe if you think about it and go over this simulation yourself, it might sink in.
\end{mdframed}
\section{Life Table Response Experiment}
Life table response experiments (LTREs) are used to assess which  differences in vital rates lead to a change in $\lambda$ in an experimental design. The experiment you performed on the rotifers is well suited to be analysed by an LTRE. More information on the LTREs can be find in Caswell (2001) \textit{Matrix population models}, this is also the book that we based the theoretical background of this practical on. 
\subsection{One-way fixed designs}
A one-way fixed effect is applied on data with one treatment of several levels. For example, let us examine two populations of yellow-necked mice. 

\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{mouse.jpg}
\caption{\label{fig:mice}yellow-necked mouse, from wikipedia.}
\end{figure}

This species lives mostly in woodlands and it is suspected that its distribution is limited by altitude. Let us compare a population living in the mountain (population $\boldsymbol{M}$) with a population living in the plain (population $\boldsymbol{P}$) to see if the altitude is a limiting distribution factor. This species can be described by a life-cylce in two stages; juveniles and adults. Thus the matrices describing those populations are given by:
<<t20,echo=F,eval=T, results='hide'>>=
P<-matrix(c(0,0.25,2,0.5), nrow=2)
M<-matrix(c(0,0.2,1.9,0.45), nrow=2)

library(popbio)
lamP<-lambda(P)
lamM<-lambda(M)
lamP
lamM
@
\begin{equation}
\boldsymbol{P}=\begin{pmatrix}
\Sexpr{P[1,1]}&\Sexpr{P[1,2]}\\
\Sexpr{P[2,1]}&\Sexpr{P[2,2]}
\end{pmatrix}
\end{equation}
and
\begin{equation}
\boldsymbol{M}=\begin{pmatrix}
\Sexpr{M[1,1]}&\Sexpr{M[1,2]}\\
\Sexpr{M[2,1]}&\Sexpr{M[2,2]}
\end{pmatrix}
\end{equation}
Find the asymptotic growth rates of these populations. You can see that they differ. We would now like to investigate which matrix elements contribute the most to the difference in the asymptotic growth rates. For this we describe the asymptotic growth rate of the mountain population matrix, $\boldsymbol{M}$, as a function of the asymptotic growth rate of the plain population matrix, $\boldsymbol{P}$ , our reference population plus a treatment effect:  

\begin{equation}\label{a}
\lambda^{(M)} \approx \lambda^{(P)}+\sum_{i,j}{(a^{(M)}_{ij}-a^{(P)}_{ij})} \frac{ \partial\lambda^{A}}{\partial a^{A}_{ij}}
\end{equation}
Let us work through the right part of this equation together. 
\begin{itemize}
\item $\lambda^{(P)}$ is the asymptotic growth rate of the $\boldsymbol{P}$ matrix. 
\item The term ${(a^{(M)}_{ij}-a^{(P)}_{ij})}$, is the change in the elements of the matrix due to the treatment effect, here the moutain habitat. It tells us how different an element in matrix $\boldsymbol{M}$ is from the element at the same position in matrix $\boldsymbol{P}$.
\item The last part, $\frac{ \partial\lambda^{A}}{\partial a^{A}_{ij}}$, is the sensitivities of the asymptotic growth rate of a "mid-way" matrix to elements of that "mid-way" matrix. This matrix is the mean between $\boldsymbol{P}$ and $\boldsymbol{M}$ and is thus given by 
\begin{equation}
\boldsymbol{A}=\frac{\boldsymbol{M}+\boldsymbol{P}}{2}
\end{equation}
The matrix $\boldsymbol{A}$ is used because we need a matrix to compare matrices $\boldsymbol{P}$ and $\boldsymbol{M}$ against. It is possible to use either matrix $\boldsymbol{P}$ or $\boldsymbol{M}$ instead but this would give more weight to the selected matrix. Therefore we use the matrix that lies just in between.
\item The multiplication of the sensitivities with the summation term defines how much the change in each elements of the matrix due to the treatment affects the asymptotic growth rate. In other word they are the contributions of the $a_{ij}$ to the effect of the habitat on the growth. It is necessary to do this because for example, a large difference between the elements in the same position may in fact have little effect on the growth if the senstitivity for this position is low. 
\end{itemize}

You may have recognized that equation \ref{a} is a linear equation ($y=b+ax$). This method makes the assumption that the relationship between the matrices is linear and that the slope of this equation is given by $\frac{ \partial\lambda^{A}}{\partial a^{A}_{ij}}$.


With equation \ref{a}, find the value of $\lambda^{(\boldsymbol{M})}$ using \texttt{R} and compare it to the value you found earlier. How different are they? More interestingly: which difference in the matrix elements is mainly responsible for this difference? Is it the juvenile survival, the adult survival or the reproductive rate?\\[1.5ex]

\textit{Hint} Find the "mid-way" matrix. For the sensitivities, either approximate them yourself or use the \texttt{sensitivity()} function from the \texttt{popbio} package
<<t21,echo=F,eval=T, results='hide'>>=
P<-matrix(c(0,0.25,2,0.5), nrow=2)
M<-matrix(c(0,0.2,1.9,0.45), nrow=2)

#Short cut:
library(popbio)

A<-(M+P)/2
lamP<-lambda(P)
lamM<-lambda(M)
lamM2<-lamP+sum((M-P)*sensitivity(A))


#alternative complete code:
a<-0.01
Sen<-matrix(NA,2,2)
lamA<-lambda(A)
for (i in 1:2){
  for (j in 1:2){
  Ap<-A
  Ap[i,j]<-A[i,j]+a
  Sen[i,j]<-(lambda(Ap)-lamA)/a
}
}
Sen
lamP<-which(eigen(P)$values==max(eigen(P)$values))
lamP+sum((M-P)*Sen)


@
\subsection{Fixed Factorial Designs (Theory)}
Factorial LTRE allows the examination of the effects of several treatments and their interactions. This is the case for your rotifer data where you have a "layer" treatment, a "pollution" treatment and a "species" treatment. Not all the combinations were investigated though; the layers "recovery" and "pollution" contained only the species BU whereas the layers "commercial" and "postpollution" contained only species BC. What difficulty would this pose if you want to compare the species to each other? Because of this, we cannot make a full factorial LTRE on the rotifer data, but we will examine subsets of the full dataset.


For example let us consider the species BU which has two treatments of the type "layer": the layers "recovery" ($r$) and "pollution" ($p$). For each of these layers it has 3 possible levels for the copper treatment: "low" ($l$), "medium" ($m$) and "high" ($h$). We thus have two factors, one with two levels, the second with three levels.

A factorial LTRE is similar to a one-way LTRE; we want to find which differences in matrix elements between a focal matrix and a reference matrix contribute the most to the difference in $\lambda$ between the two matrices. Let us take the matrix "recovery" and "low" which we call $\boldsymbol{M}^{r,l}$ as the focal matrix, for this we average the rates over all the $6$ replicates that were subject to this treatment ($r,l$). We compare it to the matrix naive to any treatment, which we call $\boldsymbol{M}^{..}$. This matrix is obtained from taking the average rates for all the matrices that we are comparing to each other (that is in this case the average of $\boldsymbol{M}^{r,l}$,$\boldsymbol{M}^{r,m}$,$\boldsymbol{M}^{r,h}$,$\boldsymbol{M}^{p,l}$,$\boldsymbol{M}^{p,m}$ and $\boldsymbol{M}^{p,h}$). Again we are interested in understanding the effect of the different treatments on the asymptotic growth rates.
\begin{equation}\label{b}
\lambda^{r,l}=\lambda^{..}+\alpha^{r}+\beta^{l}+(\alpha \beta)^{r,l}
\end{equation}
Equation \ref{b} tells us that $\lambda^{r,l}$ can be found from $\lambda^{..}$ plus an effect from the layer "recovery", an effect from the pollution "low" and an interaction between the two treatments.

To isolate the effect of each treatment, we need to look at them separately. So we examine a matrix $\boldsymbol{M}^{r.}$, where the effect of pollution is ignored. The rates of this matrix are calculated as the average of all the matrices with the layer "recovery". 
\begin{equation}\label{c}
\alpha^{r}=\sum_{ij}(a^{r.}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{A}}{\partial a^{A}_{ij}}
\end{equation}
The structure of equation \ref{c} is the same as the last part of equation \ref{a}. The matrix $\boldsymbol{A}$ is again a "mid-way" matrix between $\boldsymbol{M}^{r.}$ and $\boldsymbol{M}^{..}$. $\alpha^{r}$ tells us how large the effect of the treatment "layer" is on the asymptotic growth rate. If we want to know which matrix elements are responsible for this effect, we need to look at the separate contributions to $\alpha^r$ ($(a^{r.}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{A}}{\partial a^{A}_{ij}}$). Analogously we can also calculate $\alpha^p$.

We do the same for the second factor. We examine a matrix $\boldsymbol{M}^{.l}$, where the effect of the layer is ignored: 
\begin{equation}\label{d}
\beta^{l}=\sum_{ij}(a^{.l}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{B}}{\partial a^{B}_{ij}}
\end{equation}
For the interaction effect, we apply the same logic. We examine a matrix $\boldsymbol{M}^{rl}$ where both the effects of the layer and the pollution are taken into account so as to capture the effect of the interaction between the two factors. Because we want to isolate the interaction effect, we need to remove the effects of the layer and copper treatment.
\begin{equation}
(\alpha \beta)^{rl}=\sum_{ij}(a^{rl}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{C}}{\partial a^{C}_{ij}} -\alpha^{r}-\beta^{l}
\end{equation}
So far we have considered only the effect of the layer "recovery" and the pollution "low". Of course this can be extended to all other layers of all treatments. So in general the equations become for $k$ the level of treatment $1$ and $m$ the level of treatment $2$.

\begin{equation}\label{f}
\lambda^{k,m}=\lambda^{..}+\alpha^{k}+\beta^{m}+(\alpha \beta)^{k,m}
\end{equation}
\begin{equation}\label{e}
\alpha^{k}=\sum_{ij}(a^{k.}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{A}}{\partial a^{A}_{ij}}
\end{equation}
\begin{equation}
\beta^{m}=\sum_{ij}(a^{.m}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{B}}{\partial a^{B}_{ij}}
\end{equation}
\begin{equation}
(\alpha \beta)^{km}=\sum_{ij}(a^{km}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{C}}{\partial a^{C}_{ij}} -\alpha^{k}-\beta^{m}
\end{equation}
In these equations:
\begin{align}
A &= \frac{\boldsymbol{M^{k.}} + \boldsymbol{M^{..}}}{2} & B &= \frac{\boldsymbol{M^{.m}} + \boldsymbol{M^{..}}}{2} & C &= \frac{\boldsymbol{M^{km}} + \boldsymbol{M^{..}}}{2}
\end{align}
LTREs provide additional information to the growth rate as it describes how the different treatments affect the growth rate. In particular, LTRE allow a detailed comparison of the effect of a treatment on growth rate by examining the contribution of each survival and fertility rate to the gorwth rates of populations subjected to different treatment levels. For example, the graph below depicts the contribution of each element of populations under different copper levels to the growth rate. Each bar describes what is the contribution of an element to the growth rate when subjected to a given treatment level. What conclusions can you draw from this graph?



<<thypgraph,echo=F, eval=T, results='asis',fig.align='center'>>=
#Copper
Copper <- matrix(c(0.06, -0.08, -0.007, -0.07, 0.01, 0.04, 0.04, -0.05, 0.01), nrow=3, ncol=3)
colnames(Copper) <- c("High", "Medium", "Low")
rownames(Copper) <- c("Pj", "F", "Pa")
Coppert<-t(Copper)

par(mar=c(6.1, 6.1, 4.1, 5.1), xpd=TRUE)
barplot(Coppert,xaxt='n', xlab="", ylab="Parameters contribution",ylim=c(-0.1, 0.1), xlim=c(0,14), col=c("brown","orange", "yellow"), beside=TRUE, main="Copper level")
segments(-1,0, 13,0)
legend("topleft", 
     c("High", "Medium", "Low"), fill=c("brown","orange", "yellow"),  bty="n")
axis(side=1, at=c(3,7,11), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)

@

\section{Rotifer data analysis}
In this section, you will apply the factorial LTRE to the rotifer data to compare the layers "pollution" and "recovery". The second factor is the copper treatment with the levels "low", "high", "medium".
\begin{enumerate}
\item Load the file that contains the estimated transition rates in \texttt{R}, do not forget to set the working directory first. 
\item Because in the lab, you have made several replicates for each treatment combination, you now have a rate per replicate. We are however interested in the average rates per treatment. We want one juvenile survival rate, one adult survival rate and one fertility rate per population, per copper level and per species. For this you can use the \texttt{aggregate()} function that we have seen in practical $6$ and find the mean. Use the function three times seperately, once for each of the rates that we are interested in. Store the results in a variable. Use \texttt{?aggregate} to see how to use the function. You will need to use one special argument: \texttt{na.rm=TRUE}. This is to make sure that when there are $NA$s in the dataset, the function ignores them and still returns a value.
\item Now you have three separate lists. You want to group them. For this you can adapt the following lines of code. Use the names of the variables that you specified in the previous step.
<<t23,echo=T, eval=F>>=
younewdata1<-merge(SurvJuv, SurvAdu, by=c(1,2,3)) 
#by set the column by which to merge the two elements

younewdata2<-merge(younewdata1, Fertility, by=c(1,2,3))
@
You can in addition give a more meaningful name to the columns by using:
<<t24,echo=T, eval=F>>=
colnames(younewdata2)<-c("name of col1", 
"name of col2", "name of col3", 
"name of col4", "name of col5", "name of col6")
@
\item We mentioned that we are only interested at the moment in the layer "Recovery" and "Pollution". Both contained the species BU. Thus, select only the BU species with the \texttt{subset} function that we also used in practical $6$.
\item Below is a useful function for the LTRE. It allows you to extract a specific matrix per treatment by using \texttt{get\_matrix}. You need to give it the following arguments 1) the dataset from which you want to extract the matrix, 2) the name of the layer that you are interested in (for example "Pollution"), and 3) the name of the copper level (for example "high"). You do not need to understand the details of this code. If you run this code once during your \texttt{R}-session, \texttt{R} will remember it and every time you type \texttt{get\_matrix(data,layer,copper)} it will execute that code.
<<t26,echo=T, eval=F>>=
#code for function to extract matrices from the dataset#
get_matrix<-function(roti,pop,cop){
  if(!pop %in% c(levels(roti$Population),"mean")){
    warning("Something went wrong, give the instructors 
            a cookie and they may help you out:
            \n------------------------\n ",pop,
        " is not a valid entry\n------------------------\n")
    
    return()
  }
  
  if(!cop %in% c(levels(roti$Copper),"mean")){
    warning("Something went wrong, give the instructors 
            a cookie and they may help you out:
            \n------------------------\n ",cop," 
            is not a valid entry\n------------------------\n")
    
    return()
  }
  
  if(pop=="mean" & cop=="mean"){
    i<-1:length(roti$Copper)
  }else if(pop=="mean"){
    i<-which(roti$Copper==cop)
  }else if(cop=="mean"){
    i<-which(roti$Population==pop)
  }else{
    i<-which(roti$Population==pop & roti$Copper==cop)  
  }
  
  A<-matrix(c(0, mean(roti$Pj[i]), 
        mean(roti$F[i]), mean(roti$Pa[i])), nrow=2, ncol=2)
  return(A)
  }
#end of the function#
@
\item With the \texttt{get\_matrix} function, extract the matrix for each treatment combinations ($6$ matrices in total). You need to specify the dataset in the first position, in the second position you need to specify the layer and in the third position the copper level.
\item Get the growth rate $\lambda$ of each of these matrix.
\item Now we get to the LTRE. Let us isolate the effect of the first treatment which is the layer. This factor has two levels; pollution and recovery. What we need to do is to implement equation \ref{e} in \texttt{R}. Let us find the $\alpha$ for the level "pollution" first; $\alpha^p$. 
\begin{enumerate}
\item Find the matrix $\boldsymbol{M}^{..}$. The rates of this matrix are the averages of the rates of all the matrices of the BU species. For this you can use the \texttt{get\_matrix} function.  The second argument concerns the layer, but here we want the mean rate over all the layers, we have written the function such that you can achieve this by typing "mean" as an argument for the layer. The same holds for the third argument.
\item Next you need the mean pollution matrix, $\boldsymbol{M}^{p.}$. Again, use the \texttt{get\_matrix} function.\\[1.5ex] 
\textit{small tip} Here you can do a little trick to be able to use the code later on a different subset of your dataset. Before using the \texttt{get\_matrix} function, set a new name to your focal layers like in the code below. Then in \texttt{get\_matrix}, instead of calling for "Pollution", call for \texttt{yourname1}.

<<tpos,echo=T, eval=F>>=
yourname1<-'Pollution'
yourname2<-'Recovery'

@
\item Find the $\lambda$ for this matrix.
\item Find the "mid-way" matrix between $\boldsymbol{M}^{..}$ and $\boldsymbol{M}^{p.}$. This is the mean matrix between $\boldsymbol{M}^{..}$ and $\boldsymbol{M}^{p.}$.
\item For equation \ref{e}, you need the summation term and the sensitivity of the "mid-way" matrix. Let us look first at the summation term. You need the difference between the elements of matrix $\boldsymbol{M}^{p.}$ and of matrix $\boldsymbol{M}^{..}$. Thus take $(\boldsymbol{M}^{p.} - \boldsymbol{M}^{..})$. 
\item To find the sensitivity of the "mid-way" matrix, use the function \texttt{sensitivity} from the package \texttt{popbio} (see subsection \textit{sensitivity}). 
\item Finally, multiply the substraction matrix by the sensitivity matrix (not a matrix multiplication!) and save this in a matrix.
\item The sum of this matrix is your $\alpha^p$, the effect of the layer "Pollution" on the asymptotic growth rate. The separate entries of this matrix show how much each element of the population matrices contributes to the difference in $\lambda$ between them.
\item Store this matrix because the different elements of the matrix are what we are ultimately interested in. Check whether the effect you found indeed explains the difference between $\boldsymbol{M}^{..}$ and $\boldsymbol{M}^{p.}$.
\end{enumerate}
\item Repeat the same proceedure to find the second $\alpha$, $\alpha^r$ and store the separate contributions $(a^{k.}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{A}}{\partial a^{A}_{ij}}$. DO the same for the three values for $\beta$ and finally for the interactions. For the separate contribution of the interactions $(a^{km}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{C}}{\partial a^{C}_{ij}}$, do not forget to substract the corresponding contributions from the $\alpha$ and $\beta$. 
\item Once you have all the contributions of all the treatments, you may want to compare them. A possible graphs is a bar plot representing on the same graph the contribution to each parameter of each level of a factor, see for an example the graph above. If you agree that these sort of graphs are interesting, you can follow the next instructions. Feel free however to follow a different logic to produce the same graphs or to present your results in a different way. We do not claim to provide the most efficient code; any comments on how to improve the code are welcome.
\begin{enumerate}
\item Let us first look at the effect of the layer on the rates. One way of doing this is first to transform your matrices into vectors, using the \texttt{as.vector()} function and then combine the vector of each matrix into an array with \texttt{cbind()}. (you can actually ignore the first element of the matrices, the transition from juvenile to juvenile because it is always zero by selecting the vector elements 2 to 4). The columns are the layers and the row the rates. 
\item You can now use the \texttt{barplot()} command to plot bar graphs. Specify \texttt{beside=TRUE} to see the bars next to each other rather than on top of each other.
\item You may see that each bar (color) represents a rate although it would be more informative if each bar would be a layer. To correct for this, you can take the transpose of the array by using the function \texttt{t()} (we have seen this earlier this practical) and do the bar plot of the transpose. 
\item There are a few arguments you may want to use in the \texttt{barplot()} command to improve the visual appearance of the graph such as \texttt{xlab=}, \texttt{ylab=}, \texttt{xlim=c()}, \texttt{ylim=c()}, \texttt{col=c("colorname")}, \texttt{main="yourtitle"}.
\item Additionally, you may want to specify a legend and an axis. This you can do with the commands \texttt{legend()} and \texttt{axis()}. Look them up in the help section to see how to use them.
\item Don't forget to save your figures! A detailed description is given at the end of practical 6.
\end{enumerate}
\item Repeat all of the steps above for the combinations of the layers "Commercial" \& "Postpollution" and of the layers "Postpollution" \& "Pollution".
\end{enumerate}
If you manage to go through all the steps describe above, you should now know the growth rate of your populations, have performed three LTRE analyses on your rotifer data and have plots to include in your report. The interpretation of the results is up to you.


\begin{center}
Good luck!
\end{center}

\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{Hippocrate.jpg}
\caption{\label{fig:owl}random picture, from wikipedia.}
\end{figure}



<<tReco_vs_Post,echo=T, eval=T>>=

#Open data
rm(list = ls())
rot<-read.csv("BIO311_with_rates.csv", sep=",")
str(rot)


#Find the avg rate per treatment
Pj<-aggregate(rot$Pj, list(rot$Population, rot$Copper, rot$Species),
              na.rm=TRUE, FUN="mean")
Pj
Pa<-aggregate(rot$Pa, list(rot$Population, rot$Copper, rot$Species), 
              na.rm=TRUE, FUN="mean")
Pa
F<-aggregate(rot$F, list(rot$Population, rot$Copper, rot$Species),
             na.rm=TRUE, FUN="mean")
F
Surv<-merge(Pj, Pa,  by=c(1,2,3))
Surv


# Merge it into one dataset
Roti<-merge(Surv, F, by=c(1,2,3))

colnames(Roti)<- c("Population", "Copper", "Species", "Pj", "Pa", "F")
Roti

#Finding the lambda for each matrix (optional)
Roti$lambda<-NA

library('popbio')
for (i in 1:length(Roti$Pj)){
  M<-matrix(c(0, Roti$Pj[i], Roti$F[i], Roti$Pa[i]), nrow=2, ncol=2)
    
  Roti$lambda[i]<-lambda(M)
}
 Roti

#----------- code for function to extract matrices from the dataset-----------#
get_matrix<-function(roti,pop,cop){
  if(!pop %in% c(levels(roti$Population),"mean")){
    warning("Something went wrong, give the instructors a cookie and they may help you out:\n------------------------\n ",
            pop," is not a valid entry\n------------------------\n")
    
    return()
  }
  
  if(!cop %in% c(levels(roti$Copper),"mean")){
    warning("Something went wrong, give the instructors a cookie and they may help you out:\n------------------------\n ",
            cop," is not a valid entry\n------------------------\n")
    
    return()
  }
  
  if(pop=="mean" & cop=="mean"){
    i<-1:length(roti$Copper)
  }else if(pop=="mean"){
    i<-which(roti$Copper==cop)
  }else if(cop=="mean"){
    i<-which(roti$Population==pop)
  }else{
    i<-which(roti$Population==pop & roti$Copper==cop)  
  }
  
  A<-matrix(c(0, mean(roti$Pj[i]), mean(roti$F[i]),
              mean(roti$Pa[i])), nrow=2, ncol=2)
  return(A)
  }
#--------------------------end of the function-----------------#

#Get the matrices we are interested in (for Species BC)
library(popbio)
a<-'Pollution'
ash<-'Poll' # Short name for layer a
b<-'Recovery'
bsh<-'Rec' # Short name for layer b

Rotisub <- subset(Roti, Roti$Population==a | Roti$Population==b)
Rotisub


#Here let us do the LTRE
#two factors: population (1) and Copper (2)
#The average matrix:
M<-get_matrix(Rotisub, "mean", "mean")

#First the effect of population (1)-> alpha
Pop1<-get_matrix(Rotisub, a, "mean")
#Population level 3->Postpollution
#Population level 1->Pollution 
     #Pollution
       #The mid-way matrix 
A<-((M+Pop1)/2)
alpha1<-(Pop1-M)*sensitivity(A)
alpha1

#Recovery
Pop2<-get_matrix(Rotisub, b, "mean")
       #The mid-way matrix 
B<-((M+Pop2)/2)
alpha2<-(Pop2-M)*sensitivity(B)
alpha2

#Second the effect of Copper (2)-> beta
hig<-get_matrix(Rotisub, "mean", "high")
med<-get_matrix(Rotisub, "mean", "medium")
low<-get_matrix(Rotisub, "mean", "low")
#Copper level 1->High
#Copper leve 2->Medium
#Copper leve 3->Low
     #High
       #The mid-way matrix 
#for beta:
C<-((M+hig)/2)
beta1<-(hig-M)*sensitivity(C)
beta1


  #Medium
       #The mid-way matrix 
#for beta:
D<-((M+med)/2)

beta2<-(med-M)*sensitivity(D)
beta2

  #Low
       #The mid-way matrix 
#for beta:
E<-((M+low)/2)

beta3<-(low-M)*sensitivity(E)
beta3


#Interactions

#Here let us extract the 6 matrices we need:
Pop1h<-get_matrix(Rotisub, a, "high")
Pop1m<-get_matrix(Rotisub, a, "medium")
Pop1l<-get_matrix(Rotisub, a, "low")

Pop2h<-get_matrix(Rotisub, b, "high")
Pop2m<-get_matrix(Rotisub, b, "medium")
Pop2l<-get_matrix(Rotisub, b, "low")

       #The mid-way matrix 
#for alpha:beta:
F<-((M+Pop1h)/2)

inter1<-((Pop1h-M)*sensitivity(F))-alpha1-beta1
inter1

       #The mid-way matrix 
#for alpha:beta:
G<-((M+Pop1m)/2)
#The loop

inter2<-((Pop1m-M)*sensitivity(G))-alpha1-beta2
inter2

#The mid-way matrix 
#for alpha:beta:
H<-((M+Pop1l)/2)

inter3<-((Pop1l-M)*sensitivity(H))-alpha1-beta3
inter3
#The mid-way matrix 
#for alpha:beta:

I<-((M+Pop2h)/2)
inter4<-((Pop2h-M)*sensitivity(I))-alpha2-beta1
inter4

#The mid-way matrix 
#for alpha:beta:
J<-((M+Pop2m)/2)
inter5<-((Pop2m-M)*sensitivity(J))-alpha2-beta2
inter5

#The mid-way matrix 
#for alpha:beta:
K<-((M+Pop2l)/2)
inter6<-((Pop2l-M)*sensitivity(K))-alpha2-beta3
inter6


######### ARRANGING THE DATA FOR PLOTTING ##############
#Copper
Copper <- cbind(as.vector(beta1)[2:4], as.vector(beta2)[2:4],
                as.vector(beta3)[2:4])
colnames(Copper) <- c("High", "Medium", "Low")
rownames(Copper) <- c("Pj", "F", "Pa")
Copper
Coppert<-t(Copper)

#Layer
Layer <- cbind(as.vector(alpha1)[2:4], as.vector(alpha2)[2:4])
colnames(Layer) <- c(a, b)
rownames(Layer) <- c("Pj", "F", "Pa")
Layer
Layert<-t(Layer)

#Interactions
Interactions <- cbind(as.vector(inter1)[2:4], as.vector(inter2)[2:4], 
                      as.vector(inter3)[2:4], as.vector(inter4)[2:4],
                      as.vector(inter5)[2:4], as.vector(inter6)[2:4])
colnames(Interactions) <- axislabels
rownames(Interactions) <- c("Pj", "F", "Pa")
Interactions
Interactionst<-t(Interactions)

# Plotting
ymin<-min(c(min(Layer),min(Copper),min(Interactions)))

ymax<-max(c(max(Layer),max(Copper),max(Interactions)))

ylim<-0.03+max(c(ymax,abs(ymin)))

limits<-c(-ylim,ylim)

#graphs
par(mfrow=c(1,3),mar=c(3,3,3,7))

barplot(Coppert,xaxt='n', xlab="", ylab="Parameters contribution",
        ylim=limits, xlim=c(0,14), col=c("brown","orange", "yellow"), 
        beside=TRUE, main="Copper level")
segments(-1,0, 13,0)
par(mar=c(5.1, 5.1, 4.1, 5.1), xpd=TRUE)
legend("topleft", 
     c("High", "Medium", "Low"), fill=c("brown","orange", "yellow"),
     bty="n")
axis(side=1, at=c(3,7,11), labels=c( "Pj", "F", "Pa"), line=1,
     tick=FALSE)

barplot(Layert,xaxt='n', xlab="", ylab="", ylim=limits, xlim=c(0,14),
        col=c("blue","lightblue"), beside=TRUE, main="Layer")
segments(-1,0, 10,0)
par(mar=c(5.1, 5.1, 4.1, 5.1), xpd=TRUE)
legend("topleft",
     c(a,b), fill=c("blue","lightblue"), bty="n")
axis(side=1, at=c(2,5,8), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)



#Interaction
#Layer
axislabels<-c()
for(i in c(ash,bsh)){
  for(j in c("H","M","L")){
    axislabels<-c(axislabels,paste(i,j,sep=""))
  }
}

axislabels2<-c()
for(i in c(ash,bsh)){
  for(j in c("$+$","$\\pm$","$-$")){
    axislabels2<-c(axislabels2,paste(i,j,sep="; "))
  }
}


rainbow(6,start = 0, end = 0.5, alpha = 0.7)
library("RColorBrewer")

barplot(Interactionst, xaxt='n', xlab="", ylab="", ylim=limits, xlim=c(0,20),
        col=brewer.pal(6, "Set3") , beside=TRUE, main="Interactions")
segments(-1,0, 20,0)
par(mar=c(5.1, 5.1, 4.1, 7.1), xpd=TRUE)
legend("topleft",  
     axislabels2, fill=brewer.pal(6, "Set3"), bty="n", ncol=2,text.width=5)
axis(side=1, at=c(5,12,18), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)

@


\end{document}
