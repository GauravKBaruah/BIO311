i<-which(roti$Population==pop)
}else{
i<-which(roti$Population==pop & roti$Copper==cop)
}
A<-matrix(c(0, mean(roti$Pj[i]), mean(roti$F[i]), mean(roti$Pa[i])), nrow=2, ncol=2)
return(A)
}
polp<-get_matrix((Rotisub, "Pollution", "mean")
Rotisub <- Roti[ which(Roti$Species=="BU"),]
polp<-get_matrix(Rotisub, "Pollution", "mean")
A<-((M+pol)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
PoPL<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
polp<-get_matrix(Rotisub, "Pollution", "mean")
polp[i,j]<-pol[i,j]-M[i,j]
Ap<-A
Ap[i,j]<-A[i,j]+a
Sen[i,j]<-(lambda(Ap)-lambda(pol))/a
PoPL[i,j]<-polp[i,j]*Sen[i,j]
}
}
PoPL
pol<-(Aph+Apm+Apl)/3
pol
get_matrix(Rotisub, "pollution", "mean")
get_matrix(Rotisub, "Pollution", "mean")
pol<-get_matrix(Rotisub, "Pollution", "mean")
A<-((M+pol)/2)
M<-get_matrix(Rotisub, "mean", "mean")
M
M<-(Aph+Apm+Apl+Arh+Arm+Arl)/6
M
pol<-get_matrix(Rotisub, "Pollution", "mean")
A<-((M+pol)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
PoPL<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
polp<-pol
polp[i,j]<-pol[i,j]-M[i,j]
Ap<-A
Ap[i,j]<-A[i,j]+a
Sen[i,j]<-(lambda(Ap)-lambda(pol))/a
PoPL[i,j]<-polp[i,j]*Sen[i,j]
}
}
PoPL
#First the effect of population (1)-> alpha
pol<-(Aph+Apm+Apl)/3
#OR:
pol<-get_matrix(Rotisub, "Pollution", "mean")
rec<-(Arh+Arm+Arl)/3
#Population level 1->Pollution
#Population level 2->Recovery
#Pollution
#The mid-way matrix ((A+pol)/2)
A<-((M+pol)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
PoPL<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
polp<-pol
polp[i,j]<-pol[i,j]-M[i,j]
Ap<-A
Ap[i,j]<-A[i,j]+a
Sen[i,j]<-(lambda(Ap)-lambda(A))/a
PoPL[i,j]<-polp[i,j]*Sen[i,j]
}
}
PoPL
B<-((M+rec)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
ReC<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
recp<-rec
recp[i,j]<-rec[i,j]-M[i,j]
Bp<-B
Bp[i,j]<-B[i,j]+a
Sen[i,j]<-(lambda(Bp)-lambda(B))/a
ReC[i,j]<-recp[i,j]*Sen[i,j]
}
}
ReC
#High
#The mid-way matrix
#for beta:
C<-((M+hig)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
HiG<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
higp<-hig
higp[i,j]<-hig[i,j]-M[i,j]
Cp<-C
Cp[i,j]<-C[i,j]+a
Sen[i,j]<-(lambda(Cp)-lambda(C))/a
HiG[i,j]<-higp[i,j]*Sen[i,j]
}
}
HiG
#Second the effect of Copper (2)-> beta
hig<-get_matrix(Rotisub, "mean", "high")
med<-get_matrix(Rotisub, "mean", "medium")
low<-get_matrix(Rotisub, "mean", "low")
#Copper level 1->High
#Copper leve 2->Medium
#Copper leve 3->Low
#High
#The mid-way matrix
#for beta:
C<-((M+hig)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
HiG<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
higp<-hig
higp[i,j]<-hig[i,j]-M[i,j]
Cp<-C
Cp[i,j]<-C[i,j]+a
Sen[i,j]<-(lambda(Cp)-lambda(C))/a
HiG[i,j]<-higp[i,j]*Sen[i,j]
}
}
HiG
#Medium
#The mid-way matrix
#for beta:
D<-((M+med)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
MeD<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
medp<-med
medp[i,j]<-med[i,j]-M[i,j]
Dp<-D
Cp[i,j]<-C[i,j]+a
Sen[i,j]<-(lambda(Dp)-lambda(D))/a
MeD[i,j]<-medp[i,j]*Sen[i,j]
}
}
MeD
D<-((M+med)/2)
D
med
D<-((M+med)/2)
D
med
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
MeD<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
medp<-med
medp[i,j]<-med[i,j]-M[i,j]
Dp<-D
Dp[i,j]<-D[i,j]+a
Sen[i,j]<-(lambda(Dp)-lambda(D))/a
MeD[i,j]<-medp[i,j]*Sen[i,j]
}
}
MeD
#Low
#The mid-way matrix
#for beta:
E<-((M+low)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
LoW<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
lowp<-low
lowp[i,j]<-low[i,j]-M[i,j]
Ep<-E
Ep[i,j]<-E[i,j]+a
Sen[i,j]<-(lambda(Ep)-lambda(E)))/a
LoW[i,j]<-lowp[i,j]*Sen[i,j]
}
}
LoW
r beta:
E<-((M+low)/2)
#The loop
a<-0.01
Sen<-matrix(NA,2,2)
LoW<-matrix(NA,2,2)
for (i in 1:2){
for (j in 1:2){
lowp<-low
lowp[i,j]<-low[i,j]-M[i,j]
Ep<-E
Ep[i,j]<-E[i,j]+a
Sen[i,j]<-(lambda(Ep)-lambda(E))/a
LoW[i,j]<-lowp[i,j]*Sen[i,j]
}
}
LoW
plot(LoW)
hist(LoW)
hist(LoW, HiG)
plot(LoW, HiG)
axislabels<-c()
for(i in c(ash,bsh)){
for(j in c("H","L","M")){
axislabels<-c(axislabels,paste(i,j,sep=""))
}
}
ash<-'Post' # Short name for layer a
bsh<-'Rec' # Short name for layer b
axislabels<-c()
for(i in c(ash,bsh)){
for(j in c("H","L","M")){
axislabels<-c(axislabels,paste(i,j,sep=""))
}
}
axislabels
rm(list = ls())
rot<-read.csv("BIO311_with_rates.csv", sep=",")
str(rot)
#Find the avg rate per treatment
Pj<-aggregate(rot$Pj, list(rot$Population, rot$Copper, rot$Species), na.rm=TRUE, FUN="mean")
Pj
Pa<-aggregate(rot$Pa, list(rot$Population, rot$Copper, rot$Species), na.rm=TRUE, FUN="mean")
Pa
F<-aggregate(rot$F, list(rot$Population, rot$Copper, rot$Species), na.rm=TRUE, FUN="mean")
F
Surv<-merge(Pj, Pa,  by=c(1,2,3))
Surv
# Merge it into one dataset
Roti<-merge(Surv, F, by=c(1,2,3))
colnames(Roti)<- c("Population", "Copper", "Species", "Pj", "Pa", "F")
Roti
#Finding the lambda for each matrix (optional)
Roti$lambda<-NA
library('popbio')
for (i in 1:length(Roti$Pj)){
M<-matrix(c(0, Roti$Pj[i], Roti$F[i], Roti$Pa[i]), nrow=2, ncol=2)
Roti$lambda[i]<-lambda(M)
}
Roti
#----------- code for function to extract matrices from the dataset-----------#
get_matrix<-function(roti,pop,cop){
if(!pop %in% c(levels(roti$Population),"mean")){
warning("Something went wrong, give the instructors a cookie and they may help you out:\n------------------------\n ",pop," is not a valid entry\n------------------------\n")
return()
}
if(!cop %in% c(levels(roti$Copper),"mean")){
warning("Something went wrong, give the instructors a cookie and they may help you out:\n------------------------\n ",cop," is not a valid entry\n------------------------\n")
return()
}
if(pop=="mean" & cop=="mean"){
i<-1:length(roti$Copper)
}else if(pop=="mean"){
i<-which(roti$Copper==cop)
}else if(cop=="mean"){
i<-which(roti$Population==pop)
}else{
i<-which(roti$Population==pop & roti$Copper==cop)
}
A<-matrix(c(0, mean(roti$Pj[i]), mean(roti$F[i]), mean(roti$Pa[i])), nrow=2, ncol=2)
return(A)
}
#--------------------------end of the function-----------------#
#Get the matrices we are interested in (for Species BC)
library(popbio)
a<-'Postpollution'
ash<-'Post' # Short name for layer a
b<-'Recovery'
bsh<-'Rec' # Short name for layer b
Rotisub <- subset(Roti, Roti$Population==a | Roti$Population==b)
Rotisub
#Here let us do the LTRE
#two factors: population (1) and Copper (2)
#The average matrix:
M<-get_matrix(Rotisub, "mean", "mean")
#First the effect of population (1)-> alpha
Pop1<-get_matrix(Rotisub, a, "mean")
#Population level 3->Postpollution
#Population level 1->Pollution
#Pollution
#The mid-way matrix
A<-((M+Pop1)/2)
alpha1<-(Pop1-M)*sensitivity(A)
alpha1
#Recovery
Pop2<-get_matrix(Rotisub, b, "mean")
#The mid-way matrix
B<-((M+Pop2)/2)
alpha2<-(Pop2-M)*sensitivity(B)
alpha2
#Second the effect of Copper (2)-> beta
hig<-get_matrix(Rotisub, "mean", "high")
med<-get_matrix(Rotisub, "mean", "medium")
low<-get_matrix(Rotisub, "mean", "low")
#Copper level 1->High
#Copper leve 2->Medium
#Copper leve 3->Low
#High
#The mid-way matrix
#for beta:
C<-((M+hig)/2)
beta1<-(hig-M)*sensitivity(C)
beta1
#Medium
#The mid-way matrix
#for beta:
D<-((M+med)/2)
beta2<-(med-M)*sensitivity(D)
beta2
#Low
#The mid-way matrix
#for beta:
E<-((M+low)/2)
beta3<-(low-M)*sensitivity(E)
beta3
#Interactions
#Here let us extract the 6 matrices we need:
Pop1h<-get_matrix(Rotisub, a, "high")
Pop1m<-get_matrix(Rotisub, a, "medium")
Pop1l<-get_matrix(Rotisub, a, "low")
Pop2h<-get_matrix(Rotisub, b, "high")
Pop2m<-get_matrix(Rotisub, b, "medium")
Pop2l<-get_matrix(Rotisub, b, "low")
#The mid-way matrix
#for alpha:beta:
F<-((M+Pop1h)/2)
inter1<-((Pop1h-M)*sensitivity(F))-alpha1-beta1
inter1
#The mid-way matrix
#for alpha:beta:
G<-((M+Pop1m)/2)
#The loop
inter2<-((Pop1m-M)*sensitivity(G))-alpha1-beta2
inter2
#The mid-way matrix
#for alpha:beta:
H<-((M+Pop1l)/2)
inter3<-((Pop1l-M)*sensitivity(H))-alpha1-beta3
inter3
#The mid-way matrix
#for alpha:beta:
I<-((M+Pop2h)/2)
inter4<-((Pop2h-M)*sensitivity(I))-alpha2-beta1
inter4
#The mid-way matrix
#for alpha:beta:
J<-((M+Pop2m)/2)
inter5<-((Pop2m-M)*sensitivity(J))-alpha2-beta2
inter5
#The mid-way matrix
#for alpha:beta:
K<-((M+Pop2l)/2)
inter6<-((Pop2l-M)*sensitivity(K))-alpha2-beta3
inter6
######### ARRANGING THE DATA FOR PLOTTING ##############
#Copper
Copper <- cbind(as.vector(beta1)[2:4], as.vector(beta2)[2:4], as.vector(beta3)[2:4])
colnames(Copper) <- c("High", "Medium", "Low")
rownames(Copper) <- c("Pj", "F", "Pa")
Copper
Coppert<-t(Copper)
#Layer
Layer <- cbind(as.vector(alpha1)[2:4], as.vector(alpha2)[2:4])
colnames(Layer) <- c(a, b)
rownames(Layer) <- c("Pj", "F", "Pa")
Layer
Layert<-t(Layer)
#Interactions
Interactions <- cbind(as.vector(inter1)[2:4], as.vector(inter2)[2:4], as.vector(inter3)[2:4], as.vector(inter4)[2:4], as.vector(inter5)[2:4], as.vector(inter6)[2:4])
colnames(Interactions) <- axislabels
rownames(Interactions) <- c("Pj", "F", "Pa")
Interactions
Interactionst<-t(Interactions)
# Plotting
ymin<-min(c(min(Layer),min(Copper),min(Interactions)))
ymax<-max(c(max(Layer),max(Copper),max(Interactions)))
ylim<-max(c(ymax,abs(ymin)))
limits<-c(-ylim,ylim)
#graphs
par(mfrow=c(1,3))
barplot(Coppert,xaxt='n', xlab="", ylab="Parameters contribution", ylim=limits, xlim=c(0,14), col=c("brown","orange", "yellow"), beside=TRUE, main="Copper level")
segments(-1,0, 13,0)
par(mar=c(5.1, 5.1, 4.1, 5.1), xpd=TRUE)
legend("topleft",
c("High", "Medium", "Low"), fill=c("brown","orange", "yellow"),  bty="n")
axis(side=1, at=c(3,7,11), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)
barplot(Layert,xaxt='n', xlab="", ylab="Parameters contribution", ylim=limits, xlim=c(0,14), col=c("blue","lightblue"), beside=TRUE, main="Layer")
segments(-1,0, 10,0)
par(mar=c(5.1, 5.1, 4.1, 5.1), xpd=TRUE)
legend("topleft",
c(a,b), fill=c("blue","lightblue"), bty="n")
axis(side=1, at=c(2,5,8), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)
#Interaction
#Layer
axislabels<-c()
for(i in c(ash,bsh)){
for(j in c("H","M","L")){
axislabels<-c(axislabels,paste(i,j,sep=""))
}
}
axislabels2<-c()
for(i in c(ash,bsh)){
for(j in c("hig","med","low")){
axislabels2<-c(axislabels2,paste(i,j,sep=", "))
}
}
rainbow(6,start = 0, end = 0.5, alpha = 0.7)
library("RColorBrewer")
barplot(Interactionst, xaxt='n', xlab="", ylab="Parameters contribution", ylim=limits, xlim=c(0,20), col=brewer.pal(6, "Set3") , beside=TRUE, main="Interactions")
segments(-1,0, 20,0)
par(mar=c(5.1, 5.1, 4.1, 5.1), xpd=TRUE)
legend("topleft",
axislabels2, fill=brewer.pal(6, "Set3"), bty="n", ncol=2)
axis(side=1, at=c(5,12,18), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)
limits
?sample
gl<-list(A=A,B=B,C=C)
gl
sample(gl)
sample(gl,1)
sample(gl,2)
sample(gl,1)
gl<-c(A=A,B=B,C=C)
gl
sample(gl,2)
gl<-list(A=A,B=B,C=C)
gl
gl<-list(A,B,C)
gl
sample(gl,1)
sample(gl,1)%*%c(6,4)
sample(gl,1)[[1]]%*%c(6,4)
as.matrix(sample(gl,1)[[1]])%*%(6,4)
as.matrix(sample(gl,1)[[1]])%*%c(6,4)
A%*%c(6,4)
B%*%c(6,4)
C%*%c(6,4)
as.matrix(sample(gl,1)[[1]])%*%c(6,4)
as.matrix(sample(gl,1)[[1]])%*%c(6,4)
as.matrix(sample(gl,1))%*%c(6,4)
as.matrix(sample(gl,1))
as.matrix(sample(gl,1)[2])
as.matrix(sample(gl,1)[3])
str((sample(gl,1)))
sample(gl,1)%*%c(6,4)
sample(gl,1)[[1]]%*%c(6,4)
sample(gl,1)[1]%*%c(6,4)
sample(c(1,2,3),1,prob=c(4/7,2/7,1/7))
sample(c(1,2,3),1,prob=c(4/7,2/7,1/7))
sample(c(1,2,3),1,prob=c(4/7,2/7,1/7))
sample(c(1,2,3),1,prob=c(4/7,2/7,1/7))
sample(c(1,2,3),1,prob=c(4/7,2/7,1/7))
?sim.vit
?vit.sim
elasticity
library('popbio')
elasticity
sensitivity
A<-matrix(c(0,0,0,4,0,1,5,0,0),nrow=3)
A
A%*%c(0,1,0)
A%*%A%*%c(0,1,0)
eigen(t(A))
A
eigen(A)
A<-matrix(c(0,1,0,4,0,1,5,0,0),nrow=3)
A
eigen(t(A))
A
eigen(A)
eigen(t(A))
eigen(t(A))$vectors/(-0.2991066)
eigen(A)
A
eigen(A)
eigen(t(A))$vectors/(-0.2991066)
eigen(t(A))$vectors/
1
A
A<-matrix(c(0,1,0,5,0,1,4,0,0),nrow=3)
A
eigen(A)
eigen(t(A))
eigen(t(A))$vectors/(0.3162278)
4/9
5/9
?eigen
eigen(t(A))$vectors[,1]
lvec<-eigen(t(A))$vectors[,1]
(lvec%*%A)/lvec
lvec<-eigen(t(A))$vectors[1,]
lvec<-eigen(t(A))$vectors[,1]
lvec<-eigen(t(A))$vectors[1,]
(lvec%*%A)/lvec
